/* Code for stratigraphic tools package (http://mesquiteproject.org/... ).Copyright 2005 by Sébastien Josse, Thomas Moreau and Michel Laurin.Based on Mesquite source code copyright 1997-2005 W. & D. Maddison.Available for Mesquite version 1.06Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.stratigraphictools.STBranchLengthsAdjust;import java.util.*;import java.awt.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.stratigraphictools.NodeLocsPaleo.*;/* ======================================================================== */public class STBranchLengthsAdjust extends TreeDisplayAssistantI {	public Vector extras;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName){		extras = new Vector();		return true;	} 	/*.................................................................................................................*/	public boolean isPrerelease(){		return false;	}	/*.................................................................................................................*/	/** returns whether this module is requesting to appear as a primary choice */	public boolean requestPrimaryChoice(){		return true;  	}	/*.................................................................................................................*/	public   TreeDisplayExtra createTreeDisplayExtra(TreeDisplay treeDisplay) {		STAdjustToolExtra newPj = new STAdjustToolExtra(this, treeDisplay);		extras.addElement(newPj);		return newPj;	}	MesquiteInteger pos = new MesquiteInteger();	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Hires a module to alter or transform branch lengths", "[name of module]", commandName, "alterBranchLengths")) {			BranchLengthsAlterer ble = (BranchLengthsAlterer)hireNamedEmployee(BranchLengthsAlterer.class, arguments);			if (ble!=null) {				transformTree(ble);								fireEmployee(ble); //todo: might be good to keep it around, and remembering it if user wants to change parameters			}			//if arguments have name of estimator then use it, passing it the trees		}		else if (checker.compare(this.getClass(), "Sets branch length of selected nodes", null, commandName, "acceptBranchLengths")) {			Enumeration e = extras.elements();			while (e.hasMoreElements()) {				Object obj = e.nextElement();				STAdjustToolExtra tCO = (STAdjustToolExtra)obj;				tCO.doCommand("setLength", arguments, checker);			}		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	/*.................................................................................................................*/	void transformTree(TreeTransformer ble){		Enumeration e = extras.elements();		while (e.hasMoreElements()) {			Object obj = e.nextElement();			STAdjustToolExtra tCO = (STAdjustToolExtra)obj;			Tree t = tCO.getTree();			if (t instanceof AdjustableTree) {				boolean success = ble.transformTree((AdjustableTree)t, null, true);			}		}	}	/*.................................................................................................................*/	public String getName() {		return "Stratigraphic Branch Lengths Adjust";	}}/* ======================================================================== */class STAdjustToolExtra extends TreeDisplayExtra implements Commandable  {	TreeTool adjustTool, stretchTool;	MesquiteMenuItemSpec hideMenuItem = null;	STBranchLengthsAdjust selectModule;	Tree tree;	int originalX, originalY, lastX, lastY;	boolean lineOn = true;	double lastBL;	int editorNode = -1;	boolean dragMode = false; //default mode - if true,then drags branch to extend; needs modifier keys for editor; if false, opposite		public STAdjustToolExtra (STBranchLengthsAdjust ownerModule, TreeDisplay treeDisplay) {		super(ownerModule, treeDisplay);		selectModule = ownerModule;		stretchTool = new TreeTool(this,  "stretchAdjustor", ownerModule.getPath() , "STdragLengths.gif", 2,2,"Stretch branch", "This tool adjusts branch lengths by grabbing and stretching and then sticks it automatically to the upper adjustable scale line. This tool doesn't work with logarithmic scale.");		stretchTool.setTouchedCommand(MesquiteModule.makeCommand("touchedLengthsStretch",  this));		stretchTool.setDroppedCommand(MesquiteModule.makeCommand("droppedLengthsStretch",  this));		MesquiteCommand dragCommand = MesquiteModule.makeCommand("draggedLengthsStretch",  this);		stretchTool.setDraggedCommand(dragCommand);		dragCommand.setDontDuplicate(true);		if (ownerModule.containerOfModule() instanceof MesquiteWindow) {			((MesquiteWindow)ownerModule.containerOfModule()).addTool(stretchTool);			((MesquiteWindow)ownerModule.containerOfModule()).addTool(adjustTool);		}	}	public void doTreeCommand(String command, String arguments){		Tree tree = treeDisplay.getTree();		if (!(tree instanceof MesquiteTree)){			MesquiteMessage.warnProgrammer("Action can't be completed since tree is not a native Mesquite tree");		}		else if (tree!=null) {			((MesquiteTree)tree).doCommand(command, arguments, CommandChecker.defaultChecker);		}	}	/*.................................................................................................................*/	public   void drawOnTree(Tree tree, int drawnRoot, Graphics g) {		this.tree = tree;	}		/*.................................................................................................................*/	public   void printOnTree(Tree tree, int drawnRoot, Graphics g) {		drawOnTree(tree, drawnRoot, g);	}	/*.................................................................................................................*/	public   void setTree(Tree tree) {		this.tree = tree;	}	/*.................................................................................................................*/	public Tree getTree() {		return treeDisplay.getTree();	}	public void changeLengthsSelected(AdjustableTree tree, int node, double length) {		for (int d = tree.firstDaughterOfNode(node); tree.nodeExists(d); d = tree.nextSisterOfNode(d))			changeLengthsSelected(tree, d, length);		if (tree.getSelected(node))			tree.setBranchLength(node, length, false);	}	void stretchTouched(int node, int x, int y, String mod) {		Point newOnLine = treeDisplay.getTreeDrawing().projectionOnLine(node, x, y);		originalX = newOnLine.x;		originalY = newOnLine.y;		Graphics g = treeDisplay.getGraphics();		g.setXORMode(Color.white);		g.setColor(Color.red);		lastBL = tree.getBranchLength(node);		lastX = treeDisplay.getTreeDrawing().lineTipX[node];		lastY = treeDisplay.getTreeDrawing().lineTipY[node];		g.drawString(MesquiteDouble.toString(lastBL), lastX+10, lastY);		int ibX = treeDisplay.getTreeDrawing().lineBaseX[node];		int ibY = treeDisplay.getTreeDrawing().lineBaseY[node];		drawLine(g,ibX, ibY, lastX, lastY);		drawLine(g,ibX+1, ibY, lastX+1, lastY);		drawLine(g,ibX+2, ibY, lastX+2, lastY);		g.dispose();		lineOn=true;	}	void drawLine(Graphics g, int x, int y, int x2, int y2){		if (g==null)			return;		if (x==x2 && y>y2)			g.drawLine( x2, y2, x, y);		else			g.drawLine(x, y, x2, y2);	}	void stretchDragged(Tree t, int node, int x, int y){		Point newOnLine = treeDisplay.getTreeDrawing().projectionOnLine(node, x, y);		//WARNING":  This shouldn't result in length increase if simple click and release with no drag; must subtract original X, Y		Graphics g = treeDisplay.getGraphics();		g.setXORMode(Color.white);		g.setColor(Color.red);				int ibX = treeDisplay.getTreeDrawing().lineBaseX[node];		int ibY = treeDisplay.getTreeDrawing().lineBaseY[node];		int itX = treeDisplay.getTreeDrawing().lineTipX[node];		int itY = treeDisplay.getTreeDrawing().lineTipY[node];				double bX = ibX;		double bY = ibY;		double tX =itX;		double tY = itY;		double lengthLine =  Math.sqrt((originalY-bY)*(originalY-bY) + (originalX-bX)*(originalX-bX));		if (lengthLine!=0) {			g.drawString(MesquiteDouble.toString(lastBL), lastX+10, lastY);			double extension =  Math.sqrt((newOnLine.y-bY)*(newOnLine.y-bY) + (newOnLine.x-bX)*(newOnLine.x-bX))/lengthLine;			double bL;			if (t.getBranchLength(node)==0) {				bL = extension;			}			else{				if (t.branchLengthUnassigned(node))					bL = extension;				else					bL = t.getBranchLength(node)*extension;			}						lastBL = bL;			drawLine(g,ibX, ibY, lastX, lastY);			drawLine(g,ibX+1, ibY, lastX+1, lastY);			drawLine(g,ibX+2, ibY, lastX+2, lastY);			int newX =ibX+(int)(extension*(tX-bX));			int newY = ibY+(int)(extension*(tY-bY));			g.drawString(MesquiteDouble.toString(bL), newX+10, newY);			drawLine(g,ibX, ibY, newX, newY);			drawLine(g,ibX+1, ibY, newX+1, newY);			drawLine(g,ibX+2, ibY, newX+2, newY);			lastX= newX;			lastY = newY;		}		g.dispose();	}	void stretchDropped(MesquiteTree t, int node, int x, int y){		Point newOnLine = treeDisplay.getTreeDrawing().projectionOnLine(node, x, y);		double bX = treeDisplay.getTreeDrawing().lineBaseX[node];		double bY = treeDisplay.getTreeDrawing().lineBaseY[node];		double tX = treeDisplay.getTreeDrawing().lineTipX[node];		double tY = treeDisplay.getTreeDrawing().lineTipY[node];				NodeLocsPaleo nodeLocs = (NodeLocsPaleo) ownerModule.getEmployer().findEmployeeWithDuty(DrawTreeCoordinator.class).findEmployeeWithDuty(DrawTree.class).findEmployeeWithName("Node Locations (Paleo)");				double oldBranchLength = t.getBranchLength(node,1);		double oldBranchLengthFromBase = getHeightToRoot(t,node)-oldBranchLength;		int[] termNodes = getTermBranch(t,t.getRoot());				double DepthScale = 0;		int topNode = 0;		for(int i=0;i<termNodes.length;i++){			if(getHeightToRoot(t,termNodes[i])>DepthScale){				DepthScale=getHeightToRoot(t,termNodes[i]);				topNode=termNodes[i];			}		}		double lengthLine =  Math.sqrt((originalY-bY)*(originalY-bY) + (originalX-bX)*(originalX-bX)); 		if (lengthLine!=0) {			double extension =  Math.sqrt((newOnLine.y-bY)*(newOnLine.y-bY) + (newOnLine.x-bX)*(newOnLine.x-bX))/lengthLine;			if (t.getBranchLength(node)==0) {				t.setBranchLength(node, extension, false);			}			else{				if (t.branchLengthUnassigned(node))					t.setBranchLength(node, extension, false);				else					t.setBranchLength(node, t.getBranchLength(node)*extension, false);			}		}		else			t.setBranchLength(node, 1, false);				if(nodeLocs != null){			if(nodeLocs.getAdjustScale().getValue() /*&& nodeLocs.getMagnetism().getValue()*/){				CharacterState recup = null;				CharacterData data = nodeLocs.getScaleData();				if (data == null)					return;				double shift = 0;				double newHeight = 0;				double newLength = 0;				double daughterNewLength = 0;				boolean outOfScale=false;				int it=0;				for(it=0;  it<data.getNumTaxa(); it++) {						newHeight = new Double(data.getCharacterState(recup,2,it).toString()).doubleValue();					if((DepthScale-newHeight)<(oldBranchLengthFromBase+t.getBranchLength(node,1))){ 						break;					}				}				if((DepthScale-newHeight)>(oldBranchLengthFromBase+t.getBranchLength(node,1))){ 					outOfScale=true;				}				if(!outOfScale)					newHeight = new Double(data.getCharacterState(recup,1,it).toString()).doubleValue();				newLength = DepthScale - newHeight - oldBranchLengthFromBase;				shift = newLength - oldBranchLength;				if(newLength>0){					t.setBranchLength(node,newLength,false);					for(int d=t.firstDaughterOfNode(node);t.nodeExists(d);d=t.nextSisterOfNode(d)){						daughterNewLength = t.getBranchLength(d,1) - shift;						t.setBranchLength(d,daughterNewLength,false);					}					String dialog = "";					String external = "";					String internal = "";					double tolerance = 0;					boolean extern = nodeLocs.getMagnetExt().getValue();					boolean intern = nodeLocs.getMagnetInt().getValue();					if(extern || intern) tolerance = MesquiteDouble.queryDouble(ownerModule.getModuleWindow(), "Set tolerance", "Set tolerance to apply", 0.1);					if(extern){						int num=0;						for(int k=0;k<termNodes.length;k++){							if(getHeightToRoot(t,termNodes[k])>=(oldBranchLengthFromBase+oldBranchLength-tolerance) && getHeightToRoot(t,termNodes[k])<=(oldBranchLengthFromBase+oldBranchLength+tolerance)){								external += t.getTaxa().getTaxonName(t.taxonNumberOfNode(termNodes[k]))+"\n";								num++;								t.setBranchLength(termNodes[k],t.getBranchLength(termNodes[k],1)+shift,false);							}						}						dialog += num+" external branch(es) moved:\n"+external+"\n";					}					if(intern){						int num=0,temp=0;						for(int k=2;k<t.getNumNodeSpaces();k++){							if(t.nodeExists(t.firstDaughterOfNode(k)) && getHeightToRoot(t,k)>=(oldBranchLengthFromBase+oldBranchLength-tolerance) && getHeightToRoot(t,k)<=(oldBranchLengthFromBase+oldBranchLength+tolerance)){								num++;								temp=t.firstDaughterOfNode(k);								while(t.nodeExists(t.firstDaughterOfNode(temp))) 									temp=t.firstDaughterOfNode(temp);								internal+="("+t.getTaxa().getTaxonName(t.taxonNumberOfNode(temp))+",";								temp=t.lastDaughterOfNode(k);								while(t.nodeExists(t.lastDaughterOfNode(temp))) 									temp=t.lastDaughterOfNode(temp);								internal+=t.getTaxa().getTaxonName(t.taxonNumberOfNode(temp))+")\n";								t.setBranchLength(k,t.getBranchLength(k,1)+shift,false);								for(int d=t.firstDaughterOfNode(k);t.nodeExists(d);d=t.nextSisterOfNode(d)){									daughterNewLength = t.getBranchLength(d,1) - shift;									t.setBranchLength(d,daughterNewLength,false);								}							}						}						dialog += num+" internal branch(es) moved:\n"+internal+"\n";					}					if(!dialog.equals(""))						MesquiteMessage.notifyUser(dialog);				}			}		}		t.notifyListeners(this, new Notification(MesquiteListener.BRANCHLENGTHS_CHANGED));		Graphics g = treeDisplay.getGraphics();		g.setPaintMode(); //why is this done? getGraphics creates a new graphics object.		treeDisplay.pleaseUpdate(true);		lineOn=false;		if (g!=null)			g.dispose();	}	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) { 		MesquiteTree t=null; //		if (treeDisplay!=null) {			Tree trt = treeDisplay.getTree();			if (trt instanceof MesquiteTree)				t = (MesquiteTree)trt;			else				t = null;		}		if (checker.compare(this.getClass(), "Sets the branch length of the current branch", "[length]", commandName, "setLength")){			if (t==null)				return null;			if (editorNode>=0) {				if (StringUtil.blank(arguments))					return null;				if ("unassigned".equalsIgnoreCase(arguments)) {					if (t.getSelected(editorNode)) {						changeLengthsSelected(t, t.getRoot(), MesquiteDouble.unassigned);						t.notifyListeners(this, new Notification(MesquiteListener.BRANCHLENGTHS_CHANGED));					}					else						t.setBranchLength(editorNode, MesquiteDouble.unassigned, true);					MesquiteModule mb = ownerModule.findEmployerWithDuty(TreeWindowMaker.class);					mb.doCommand("treeEdited", null, checker);				}				else {					double d = MesquiteDouble.fromString(arguments);					if (MesquiteDouble.isCombinable(d)) {						if (t.getSelected(editorNode)) {							changeLengthsSelected(t, t.getRoot(), d);							t.notifyListeners(this, new Notification(MesquiteListener.BRANCHLENGTHS_CHANGED));						}						else {							t.setBranchLength(editorNode, d, true);						}						MesquiteModule mb = ownerModule.findEmployerWithDuty(TreeWindowMaker.class);						mb.doCommand("treeEdited", null, checker);					}				}			}		}		else if (checker.compare(this.getClass(), "Touch on branch to stretch it", "[branch number] [x coordinate touched] [y coordinate touched] [modifiers]", commandName, "touchedLengthsStretch")) {			if (t==null)				return null;			MesquiteInteger io = new MesquiteInteger(0);			int node= MesquiteInteger.fromString(arguments, io);			int x= MesquiteInteger.fromString(arguments, io);			int y= MesquiteInteger.fromString(arguments, io);			String mod= ParseUtil.getRemaining(arguments, io);			stretchTouched(node, x, y, mod);					}		else if (checker.compare(this.getClass(), "Drop branch whose length is being changed.", "[branch number] [x coordinate dropped] [y coordinate dropped] ", commandName, "droppedLengthsAdjust")) {			if (t==null)				return null;			MesquiteInteger io = new MesquiteInteger(0);			int node= MesquiteInteger.fromString(arguments, io);			int x= MesquiteInteger.fromString(arguments, io);			int y= MesquiteInteger.fromString(arguments, io);			if (lineOn) {				stretchDropped(t, node, x, y);			}		}		else if (checker.compare(this.getClass(),  "Drop branch being stretched.", "[branch number] [x coordinate dropped] [y coordinate dropped] ", commandName, "droppedLengthsStretch")) {			if (t==null)				return null;			MesquiteInteger io = new MesquiteInteger(0);			int node= MesquiteInteger.fromString(arguments, io);			int x= MesquiteInteger.fromString(arguments, io);			int y= MesquiteInteger.fromString(arguments, io);			if (lineOn) {				stretchDropped(t, node, x, y);			}		}						else if (checker.compare(this.getClass(),  "Drag branch whose length is being changed.", "[branch number] [current x coordinate] [current y coordinate] ", commandName, "draggedLengthsAdjust")) {			if (t==null)				return null;			MesquiteInteger io = new MesquiteInteger(0);			int node= MesquiteInteger.fromString(arguments, io);			int x= MesquiteInteger.fromString(arguments, io);			int y= MesquiteInteger.fromString(arguments, io);			if (lineOn) {				stretchDragged(t, node, x, y);			}		}		else if (checker.compare(this.getClass(), "Drag branch being stretched.", "[branch number] [current x coordinate] [current y coordinate] ", commandName, "draggedLengthsStretch")) {			if (t==null)				return null;			MesquiteInteger io = new MesquiteInteger(0);			int node= MesquiteInteger.fromString(arguments, io);			int x= MesquiteInteger.fromString(arguments, io);			int y= MesquiteInteger.fromString(arguments, io);			if (lineOn) {				stretchDragged(t, node, x, y);			}		}		return null;	}	public void turnOff() {		selectModule.extras.removeElement(this);		super.turnOff();	}		public  double getHeightToRoot(Tree t, int node) { 		if(node==t.getRoot() || !t.nodeExists(node)) return 0;		else return t.getBranchLength(node,1)+getHeightToRoot(t,t.motherOfNode(node));	}		public int[] getTermBranch(Tree t,int node){		int[] termBranchNode = new int[t.numberOfTerminalsInClade(node)];		intI=0;		findTermNodes(t,node,termBranchNode);		return termBranchNode;	}	private int intI=0;	private void findTermNodes(Tree t,int node,int[] termNodes){		for(int daughter=t.firstDaughterOfNode(node);t.nodeExists(daughter);daughter=t.nextSisterOfNode(daughter)){			if(!t.nodeExists(t.firstDaughterOfNode(daughter))){				termNodes[intI]=daughter;				intI++;			}			findTermNodes(t,daughter,termNodes);		}	}	}