/* Code for stratigraphic tools package (http://mesquiteproject.org/... ).Copyright 2005 by Sï¿½bastien Josse, Thomas Moreau and Michel Laurin.Based on Mesquite source code copyright 1997-2005 W. & D. Maddison.Available for Mesquite version 1.06Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.stratigraphictools.ScaleDataWindowMaker; /*~~  */import java.util.Enumeration;import java.util.Vector;import java.awt.*;import java.awt.event.*;import mesquite.stratigraphictools.*;import mesquite.stratigraphictools.ManageScaleTimes.ManageScaleTimes;import mesquite.stratigraphictools.ScaleDataWindowCoord.*;import mesquite.stratigraphictools.ScaleFileManager.*;import mesquite.stratigraphictools.lib.*;import mesquite.stratigraphictools.NodeLocsPaleo.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import java.awt.datatransfer.*;import mesquite.lib.table.*;//import mesquite.categ.lib.*;/** Makes and manages the spreadsheet editor for character matrices. */public class ScaleDataWindowMaker extends DataWindowMaker implements CommandableOwner  {	public static final short cellWidth = 24;	public static final short cellHeight = 16;	private CharacterData data;	private ScaleDataWindow bdw;	private MesquiteMenuItemSpec open, save, saveAs, bar;	private ScaleFileManager scaleFile;	private boolean firstSave = true;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		makeMenu("Scale Matrix");		open = addMenuItem(null, "Open an existing scale matrix...", makeCommand("openScaleMatrix", this));		save = addMenuItem(null, "Save the current scale matrix", makeCommand("saveScaleMatrix", this));		saveAs = addMenuItem(null, "Save the current scale matrix as...", makeCommand("saveScaleMatrixAs", this));		bar = addMenuItem("-", null);		scaleFile = new ScaleFileManager();		scaleFile.setPath(getProject().getHomeDirectoryName());		scaleFile.setProjectPath(getProject().getHomeDirectoryName());		resetContainingMenuBar();		return true;	}	public  Commandable[] getCommandablesForAccumulation(){		Commandable[] cs = new Commandable[1];		cs[0]= new ScaleDataWindow();		return cs;	}	/*.................................................................................................................*/	public CharacterData getCharacterData(){		return data;	}	public void setData(CharacterData data){		this.data = data;	}	public ScaleFileManager getScaleFile(){		return scaleFile;	}	/*.................................................................................................................*/	public void linkEditor(DataWindowMaker mb, boolean linkeeIsNew){	}	public void unlinkEditor(DataWindowMaker mb){	}	public MesquiteTable getTable(){		return null;	}	public void demandCellColorer(MesquiteModule m, int ic, int it, String message){	}	/*.................................................................................................................*/	public Snapshot getSnapshot(MesquiteFile file) { 		if (bdw == null)			return null;		Snapshot temp = new Snapshot();		temp.addLine("getWindow"); 		temp.addLine("tell It");		Snapshot sn = bdw.getSnapshot(file);		temp.incorporate(sn, true);		temp.addLine("endTell");		temp.addLine("showWindow"); 		if (!bdw.widthsSet && (bdw.table.tight.getValue() || bdw.table.showStates.getValue())) { //needed to ensure appears correctly first time under some OS's			temp.addLine("getWindow"); 			temp.addLine("tell It"); 			temp.addLine("\tforceAutosize");			temp.addLine("endTell"); 		}		return temp;	}	MesquiteInteger pos = new MesquiteInteger();	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Returns the data matrix shown by the data window", null, commandName, "getDataSet")) {			return data;		}		else if (checker.compare(this.getClass(), "Makes a data editor window (but doesn't display it)", "[number or reference string of data set to be shown]", commandName, "makeWindow")) {			if (bdw != null)				return bdw;			if (data !=null) {				makeDataWindow(data);				return bdw;			}			else {				STTaxa tax = new STTaxa(1);				//tax.setScaleTaxa();				Taxon t1 = new Taxon(tax);				t1.setName("Period 1");				tax.setTaxon(0,t1);				ManageScaleTimes ScaleType = new ManageScaleTimes();				Parser dataValue = new Parser();					data = ScaleType.getNewData(tax,3);				data.setCharacterName(0,"Duration of each period");				data.setCharacterName(1,"End of the period");				data.setCharacterName(2,"Beginning of the period");				dataValue.setString("0");				data.setState(0, 0, dataValue, true, null);				data.setState(1, 0, dataValue, true, null);				data.setState(2, 0, dataValue, true, null);				NameReference colorNameRef = NameReference.getNameReference("color");				MesquiteInteger ms = new MesquiteInteger(0);				data.setCellObject(colorNameRef,-1,0,ms);				data.setCellObject(colorNameRef,0,0,ms);				data.setCellObject(colorNameRef,1,0,ms);				data.setCellObject(colorNameRef,2,0,ms);				makeDataWindow(data);				return bdw;			}		}		else if (checker.compare(this.getClass(), "Sets the scale file", "[file path]", commandName, "setScaleFile")) {			String path="";			if (arguments != null && arguments.indexOf("<space>")>=0){  //old style; read but avoid writing!				char[] temp=arguments.toCharArray();  //WPM no; should use tokenization				path="";				for(int i=0;i<temp.length;i++){					if((i<(temp.length-1) && temp[i]==' ' && temp[i+1]=='\'') || (i<(temp.length-1) && temp[i+1]==' ' && temp[i]=='\'')){						i++;					}					else 						if(temp[i]!='\''){							path+=temp[i];						}				}				temp=path.toCharArray();				path="";				for(int i=0;i<temp.length;i++){					if(i<temp.length-6 && temp[i]=='<' && temp[i+1]=='s' && temp[i+2]=='p' && temp[i+3]=='a' && temp[i+4]=='c' && temp[i+5]=='e' && temp[i+6]=='>'){						path+=" ";						i+=6;					}					else path+=temp[i];				}			}			else {				path = parser.getFirstToken(arguments);				path = MesquiteFile.composePath(getProject().getHomeDirectoryName(), path);				}			//need to 			MesquiteTrunk.mesquiteTrunk.logln("Scale file reference found : "+path);			CharacterData cData=scaleFile.read(path);			if(cData != null) {				data = cData;				getEmployeeVector().removeAllElements(false);				bdw.mCC.disconnect();				bdw.mSetColor.disconnect();				deleteMenuItem(bdw.mCC);				deleteMenuItem(bdw.mSetColor);				deleteMenuItem(bdw.mRemoveColor);				deleteMenuItem(bdw.mMovePeriod);				deleteMenuItem(bdw.bar);				bdw.dispose();				bdw = null;				makeDataWindow(data);				ScaleDataWindowCoord sdw =(ScaleDataWindowCoord)getEmployer();				sdw.setScaleData(data);				showScaleDataWindow();			}			return cData;		}		else if (checker.compare(this.getClass(), "Open an existing Scale Matrix", "", commandName, "openScaleMatrix")) {			if (bdw != null) {				CharacterData cData;				cData = scaleFile.read(bdw);				if(cData != null) {					data = cData;					getEmployeeVector().removeAllElements(false);					bdw.mCC.disconnect();					bdw.mSetColor.disconnect();					deleteMenuItem(bdw.mCC);					deleteMenuItem(bdw.mSetColor);					deleteMenuItem(bdw.mRemoveColor);					deleteMenuItem(bdw.mMovePeriod);					deleteMenuItem(bdw.bar);					bdw.dispose();					bdw = null;					makeDataWindow(data);					ScaleDataWindowCoord sdw =(ScaleDataWindowCoord)getEmployer();					sdw.setScaleData(data);					showScaleDataWindow();					cData = null;										MesquiteTrunk.mesquiteTrunk.logln("File "+scaleFile.getFileName()+" opened succesfully\n");					firstSave = false;				}			}			return null;		}		else if (checker.compare(this.getClass(), "Save the current Scale Matrix", "", commandName, "saveScaleMatrix")) {			if(bdw != null) {				scaleFile.write(bdw, (ScaleData)data, firstSave);				firstSave = false;				//bdw.getSnapshot(getProject().getHomeFile());			}			return null;		}		else if (checker.compare(this.getClass(), "Save the current Scale Matrix in a new file", "", commandName, "saveScaleMatrixAs")) {			if(bdw != null) {				scaleFile.write(bdw, (ScaleData)data, true);				//bdw.getSnapshot(getProject().getHomeFile());			}			return null;		}		else			return  super.doCommand(commandName, arguments, checker);	}	public void requestCellColorer(MesquiteModule m, int ic, int it, String message){		if (bdw != null)			bdw.requestCellColorer(m, message);	}	/*.................................................................................................................*/	public void makeDataWindow(CharacterData data){		this.data=data;		ScaleDataWindowCoord sdw =(ScaleDataWindowCoord)getEmployer();		sdw.setScaleData(data);		bdw = new ScaleDataWindow(this, data);		setModuleWindow(bdw);		resetContainingMenuBar();		resetAllWindowsMenus();		MesquiteModule cc = findEmployeeWithDuty(CellColorer.class);		bdw.requestCellColorer(cc,"");	}	public void showScaleDataWindow() {		if(bdw!=null) {			getModuleWindow().setVisible(true);		}	}	/*.................................................................................................................*/	public void windowGoAway(MesquiteWindow whichWindow) {		whichWindow.hide();		whichWindow.dispose();		iQuit();	}	/*.................................................................................................................*/	public boolean showCitation() {		return true;	}	/*.................................................................................................................*/	public boolean isPrerelease() {		return false;	}	/*.................................................................................................................*/	public String getName() {		return "Scale Matrix Editor";	}	/*.................................................................................................................*/	/** returns an explanation of what the module does.*/	public String getExplanation() {		return "Makes editor windows to edit scale data." ;	}	public String getParameters(){		if (bdw == null)			return null;		return bdw.getParameters();	}}/* ======================================================================== */class ScaleDataWindow extends TableWindow implements MesquiteListener {	CharacterData data;	ScaleMatrixTable table;	int windowWidth = 850;	int windowHeight = 250;	int columnWidth = 12;	boolean widthsSet = true;	ScaleDataWindowPalette palette = null;	TableTool arrowTool,ibeamTool;	MesquiteString cellColorerName, textColorerName, bgColorName;	private int findNumber = 0;	private String findFootnoteString = "";	MesquiteBoolean constrainedCW= new MesquiteBoolean(true);	MesquiteSubmenuSpec mCC, mSetColor;	MesquiteMenuItemSpec mRemoveColor, mMovePeriod, bar;	public ScaleDataWindow () {	}	public ScaleDataWindow (ScaleDataWindowMaker ownerModule, CharacterData data) {		super(ownerModule, true); //INFOBAR		setWindowSize(windowWidth,windowHeight);		ownerModule.setModuleWindow(this);		this.data = data;		if (data!=null)			columnWidth = 160;		this.ownerModule = ownerModule;		table = new ScaleMatrixTable((ScaleDataWindowMaker)ownerModule, this, data, data.getTaxa().getNumTaxa(), data.getNumChars(), windowWidth, windowHeight, 250);		table.setQuickMode(true);		setDefaultAnnotatable(data);		data.getTaxa().addListener(this);		data.addListener(this);		//TODO: put the method in protected instead of private		//setPalette(palette = new ScaleDataWindowPalette(ownerModule, this));		addToWindow(table);		table.setLocation(0,0);		table.setVisible(true);		table.setColumnAssociable(data);		table.setRowAssociable(data.getTaxa());		mCC = ownerModule.addSubmenu(null, "Color Period", MesquiteModule.makeCommand("colorCells",  this), ownerModule.getEmployeeVector());		mCC.setListableFilter(CellColorer.class);		mCC.setCompatibilityCheck(data.getStateClass());		cellColorerName = new MesquiteString();		mCC.setSelected(cellColorerName);		mSetColor = ownerModule.addSubmenu(null, "Assign Color to Selected period", MesquiteModule.makeCommand("assignColor",  this), ColorDistribution.standardColorNames);		mRemoveColor = ownerModule.addMenuItem("Remove Color from Selected period", MesquiteModule.makeCommand("removeColor",  this));		if(mCC != null && mSetColor != null && mRemoveColor != null)			bar=ownerModule.addMenuItem("-", null);		String selectExplanation = "This tool selects items in the matrix.  By holding down shift while clicking, the selection will be extended from the first to the last touched cell. ";		selectExplanation += " A block of cells can be selected either by using shift-click to extend a previous selection, or by clicking on a cell and dragging with the mouse button still down";		selectExplanation += " Discontinous selections are allowed, and can be obtained by a \"meta\"-click (right mouse button click, or command-click on a MacOS system). ";		arrowTool = new TableTool(this, "arrow", MesquiteModule.getRootImageDirectoryPath(),"arrow.gif", 4,2,"Select", selectExplanation, MesquiteModule.makeCommand("arrowTouchCell",  this) , MesquiteModule.makeCommand("arrowDragCell",  this), MesquiteModule.makeCommand("arrowDropCell",  this));		arrowTool.setIsArrowTool(true);		arrowTool.setUseTableTouchRules(true);		addTool(arrowTool);		setCurrentTool(arrowTool);		arrowTool.setInUse(true);		//ibeam		ibeamTool = new TableTool(this, "ibeam", MesquiteModule.getRootImageDirectoryPath(),"ibeam.gif", 7,7,"Edit", "This tool can be used to edit the contents of cells in the matrix.", MesquiteModule.makeCommand("editCell",  (Commandable)table) , null, null);		ibeamTool.setWorksOnRowNames(true);		ibeamTool.setWorksOnColumnNames(false);		addTool(ibeamTool);		ownerModule.hireNamedEmployee(DataWindowAssistantI.class, "#AddDeleteDataScale");		ownerModule.hireNamedEmployee(DataWindowAssistantI.class, "#ColorScaleCells");		Enumeration e=ownerModule.getEmployeeVector().elements();		while (e.hasMoreElements()){			Object obj = e.nextElement();			if (obj instanceof DataWindowAssistantI) {				DataWindowAssistantI init = (DataWindowAssistantI)obj;				init.setTableAndData(table, data);			}		}		mMovePeriod = ownerModule.addMenuItem( "Move Selected Period To...", MesquiteModule.makeCommand("moveTaxaTo", this));		//mMovePeriod = ownerModule.addMenuItem( "Move Selected Period To...", ownerModule.makeCommand("moveTaxaTo", this));		setShowAnnotation(true);		table.requestFocus();		MesquiteWindow.addKeyListener(this, table);		MesquiteMenuItemSpec mm = ownerModule.addMenuItem(MesquiteTrunk.editMenu, "Find Footnote...", MesquiteModule.makeCommand("findFootnoteString", this));		mm.setShortcut(KeyEvent.VK_H);		calculation();		resetTitle();	}	/*.................................................................................................................*/	/** When called the window will determine its own title.  MesquiteWindows need	 to be self-titling so that when things change (names of files, tree blocks, etc.)	 they can reset their titles properly*/	public void resetTitle(){		String t;		t = "Edit the adjustable scale";		setTitle(t);	}	public boolean showFindMenuItems(){		return true;	}	public String getFindLabel(){		return "Find String in Matrix...";	}	public String getFindMessageName(){		return "cell of Scale Matrix";	}	/*.................................................................................................................*/	private boolean containsShift(String s){		if (s==null)			return false;		else			return (s.indexOf("shift")>=0);	}	/*.................................................................................................................*/	/* highlights ith cell with footnote */	boolean highlightCellWithFootnote(String s, int i){		MesquiteTable table = getTable();		if (table == null)			return false;		int count = 0;		Taxa taxa = data.getTaxa();		//search taxon footnotes		for (int it = 0; it<table.getNumRows(); it++) {			String c = taxa.getAnnotation(it);			if (StringUtil.foundIgnoreCase(c, s)){				if (count == i) {					selectAndFocus(-1, it);					return true;				}				count++;			}		}		//search character footnotes		for (int ic = 0; ic<table.getNumColumns(); ic++) {			String c = data.getAnnotation(ic);			if (StringUtil.foundIgnoreCase(c, s)){				if (count == i) {					selectAndFocus(ic, -1);					return true;				}				count++;			}		}		//search cell footnotes		for (int ic = 0; ic<table.getNumColumns(); ic++) {			for (int it = 0; it<table.getNumRows(); it++) {				String c = data.getAnnotation(ic, it);				if (StringUtil.foundIgnoreCase(c, s)){					if (count == i) {						selectAndFocus(ic, it);						return true;					}					count++;				}			}		}		return false;	}	/*.................................................................................................................*/	int rowFirstTouched=0;	int columnFirstTouched=0;	int rowLastTouched=0;	int columnLastTouched=0;	/*.................................................................................................................*/	public Snapshot getSnapshot(MesquiteFile file) { 		Snapshot temp = new Snapshot();		//temp.incorporate(super.getSnapshot(file), false);		String scaleFilePath=((ScaleDataWindowMaker)ownerModule).getScaleFile().getFileName(); //+((ScaleDataWindowMaker)ownerModule).getScaleFile().getFileName();		/*char[] sfp=scaleFilePath.toCharArray();  //WPM change Dec 09: for NEXUS compatibility		scaleFilePath="";		for(int i=0;i<sfp.length;i++){			if(sfp[i]==' ')				scaleFilePath+="<space>";			else				scaleFilePath+=sfp[i];		}*/		temp.addLine("scaleFile "+StringUtil.tokenize(MesquiteFile.decomposePath(ownerModule.getProject().getHomeFile().getDirectoryName(), scaleFilePath)));		/*		temp.addLine("setTool " +  getCurrentTool().getName()); 		//if (table != null && table.cellColorer !=null)			//temp.addLine("colorCells ", (MesquiteModule)table.cellColorer);		if (table != null && table.textColorer !=null)			temp.addLine("colorText ", (MesquiteModule)table.textColorer);		if (widthsSet)			temp.addLine("setColumnWidth " + columnWidth);		for (int i = 0; i<ownerModule.getNumberOfEmployees(); i++) {			Object e=ownerModule.getEmployeeVector().elementAt(i);			if (e instanceof DataWindowAssistant && !(e instanceof DataWindowAssistantI)) {				temp.addLine("newAssistant " , ((MesquiteModule)e));			}		}*/		return temp;	}	NameReference colorNameRef = NameReference.getNameReference("color");	private void setColor(int ic, int it, int c) {		if (data == null)			return;		if (ic<0 && it<0){		}		else if (ic<0) { //taxon			data.getTaxa().setAssociatedLong(colorNameRef, it, c);			setColor(0,it,c);		}		else if (it < 0){ //character			data.setAssociatedLong(colorNameRef, ic, c);		}		else if (!MesquiteLong.isCombinable(c) || c<0){			data.setCellObject(colorNameRef, ic, it, null);			data.setCellObject(colorNameRef, -1, it, null);		}		else {			MesquiteInteger ms = new MesquiteInteger((int)c);			data.setCellObject(colorNameRef, ic, it, ms);			data.setCellObject(colorNameRef, -1, it, ms);		}	}	private void removeColor(int ic, int it){		setColor(ic, it, 4);	}	MesquiteInteger pos = new MesquiteInteger(0);	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Sets the current tool", "[name of tool]", commandName, "setTool")) {			ToolPalette palette = getPalette();			if (palette == null)				return null;			setCurrentTool((TableTool)palette.getToolWithName(arguments));		}		else if (checker.compare(this.getClass(), "Sets the scale file", "[file path]", commandName, "scaleFile")) {			((ScaleDataWindowMaker)ownerModule).doCommand("setScaleFile",arguments,checker);			return null;		}		else if (checker.compare(this.getClass(), "Assigns color assigned to selected cells", "[name of color]", commandName, "assignColor")) {			if (table.anythingSelected()){				int bc = ColorDistribution.standardColorNames.indexOf(ParseUtil.getFirstToken(arguments, new MesquiteInteger(0))); 				if (bc >=0 && MesquiteInteger.isCombinable(bc)) {					for (int ic = -1; ic<data.getNumChars(); ic++) {						for (int it = -1; it<data.getNumTaxa(); it++){							if (table.isCellSelectedAnyWay(ic, it)) {								setColor(ic, it, bc);							}						}					}				}				if (!MesquiteThread.isScripting())					calculation();   				table.repaintAll();			}			else if (!MesquiteThread.isScripting())				ownerModule.alert("Cells must be selected in order to assign colors");		}		else	if (checker.compare(this.getClass(), "Removes color assigned from selected cells", null, commandName, "removeColor")) {			if (table.anythingSelected()){				for (int ic = -1; ic<data.getNumChars(); ic++)					for (int it = -1; it<data.getNumTaxa(); it++){						if (table.isCellSelectedAnyWay(ic, it))							removeColor(ic, it);					}				if (!MesquiteThread.isScripting())					calculation(); 				table.repaintAll();			}			else if (!MesquiteThread.isScripting())				ownerModule.alert("Cells must be selected in order to assign colors");		}		else if (checker.compare(this.getClass(), "Finds footnote containing string, selects cell and ensures it is shown", null, commandName, "findFootnoteString")) {			if (MesquiteThread.isScripting()) //todo: should support argument passed				return null;			findNumber = 0;			String temp = MesquiteString.queryString(this, "Find cell", "Find first footnote containing the following string:", findFootnoteString, 2);			if (StringUtil.blank(temp)) {				return null;			}			findString = "";			findFootnoteString = temp;			if (!highlightCellWithFootnote(findFootnoteString, findNumber))				findNumber = 0;			else				findNumber = 1;		}		else if (checker.compare(this.getClass(), "Finds footnote containing string, selects cell and ensures it is shown", null, commandName, "findAgain")) {			if (MesquiteThread.isScripting()) //todo: should support argument passed				return null;			if (findString != null && !findString.equals("")){				return  super.doCommand(commandName, arguments, checker);			}			if (StringUtil.blank(findFootnoteString))				return null;			if (!highlightCellWithFootnote(findFootnoteString, findNumber))				findNumber = 0;			else				findNumber++;		}		else if (checker.compare(this.getClass(), "Not functioning", null, commandName, "moveSelection")) {			MesquiteInteger io = new MesquiteInteger(0);			int column= MesquiteInteger.fromString(arguments, io);			int row= MesquiteInteger.fromString(arguments, io);		}		else if (checker.compare(this.getClass(), "Adds Period", "[Period number after which new Period to be inserted] [number of new Period]", commandName, "addTaxa")) {			MesquiteInteger io = new MesquiteInteger(0);			int starting= Taxon.toInternal(MesquiteInteger.fromString(arguments, io));			int number= MesquiteInteger.fromString(arguments, io);			if (data.getTaxa().addTaxa(starting, number, true))				table.setNumRows(data.getNumTaxa());		}		else if (checker.compare(this.getClass(), "Deletes Period", "[first Period to be deleted] [number of Period]", commandName, "deleteTaxa")) {			MesquiteInteger io = new MesquiteInteger(0);			int starting= Taxon.toInternal(MesquiteInteger.fromString(arguments, io));			int number= MesquiteInteger.fromString(arguments, io);			if (data.getTaxa().deleteTaxa(starting, number, true))				table.setNumRows(data.getNumTaxa());		}		else if (checker.compare(this.getClass(), "Moves the selected Period ", "[row to move after; -1 if at start]", commandName, "moveTaxaTo")) {			if (!table.anyRowSelected()){				ownerModule.discreetAlert( "Sorry, to move Period they must be selected first");				return null;			}			MesquiteInteger io = new MesquiteInteger(0);			int justAfter= MesquiteInteger.fromString(arguments, io);			if (!MesquiteInteger.isCombinable(justAfter))				justAfter = MesquiteInteger.queryInteger(this, "Move Period", "After which row should the selected Period be moved (enter 0 to move to first place)?", 0,  0, table.getNumRows()*10);			if (MesquiteInteger.isCombinable(justAfter))				table.selectedRowsDropped(justAfter-1); //-1 to convert to internal representation		}		/*This is a hidden feature to help recover from consequences of bug of duplicate NOTES blocks in linked files in 1.0 to 1.02*/		else if (checker.compare(this.getClass(), "Moves the footnotes of the selected Times ","[column to move after; -1 if at start]", commandName, "moveFootnotes")) {			if (!table.anyColumnSelected()){				ownerModule.discreetAlert( "Sorry, to move footnotes, characters must be selected first.");				return null;			}			MesquiteInteger io = new MesquiteInteger(0);			int justAfter= MesquiteInteger.fromString(arguments, io);			if (!MesquiteInteger.isCombinable(justAfter))				justAfter = MesquiteInteger.queryInteger(this, "Move footnotes", "After which column should the footnotes of the selected Times be moved (enter 0 to move to first place)?", 0,  0, table.getNumColumns()*10);			if (MesquiteInteger.isCombinable(justAfter)) {				int after = (justAfter-1); //-1 to convert to internal representation				if (after < -1)					return null;				if (after > table.getNumColumns())					after = table.getNumColumns();				int i = 0;				Bits sel = table.getColumnsSelected();				boolean asked = false;				ObjectArray charNotes = data.getWhichAssociatedObject(NameReference.getNameReference("comments"));				while (i<table.getNumColumns()) {					if (sel.isBitOn(i)) {						table.deselectColumn(i);						sel.clearBit(i);						if (i<after) {							for (int ic=i; ic<after; ic++) {								if (table.isColumnSelected(ic+1))									table.selectColumn(ic);								else									table.deselectColumn(ic);							}						} 						StringArray.moveColumns(data.getFootnotes(), i,1,after); 						if (charNotes != null)							charNotes.moveParts(i,1,after);						sel.moveParts(i, 1, after);						if (i>after)							after++;						i=0;					}					else						i++;				}				table.synchronizeColumnSelection(data);				data.notifyListeners(this, new Notification(MesquiteListener.ANNOTATION_CHANGED));				contentsChanged();			}		}		/**/		else if (checker.compare(this.getClass(), "Hires utility module to operate on the data", "[name of module]", commandName, "doUtility")) {			if (table!=null && data !=null){				DataUtility tda= (DataUtility)ownerModule.hireNamedEmployee(DataUtility.class, arguments);				if (tda!=null) {					boolean a = tda.operateOnData(data);					if (a) {						table.repaintAll();						data.notifyListeners(this, new Notification(MesquiteListener.DATA_CHANGED));					}					if (!tda.pleaseLeaveMeOn())						ownerModule.fireEmployee(tda);				}			}		}		else if (checker.compare(this.getClass(), "Hires utility module to alter names of the Period", "[name of module]", commandName, "doNames")) {			if (table!=null && data !=null){				Taxa taxa = data.getTaxa();				TaxonNameAlterer tda= (TaxonNameAlterer)ownerModule.hireNamedEmployee(TaxonNameAlterer.class, arguments);				if (tda!=null) {					boolean a = tda.alterTaxonNames(taxa, getTable());					ownerModule.fireEmployee(tda);					if (a)						taxa.notifyListeners(this, new Notification(NAMES_CHANGED, (int[])null));				}			}		}		else if (checker.compare(this.getClass(), "Sets width of columns of matrix", "[width]", commandName, "setColumnWidth")) {			MesquiteInteger io = new MesquiteInteger(0);			widthsSet = true;			int newWidth= MesquiteInteger.fromFirstToken(arguments, io);			if (!MesquiteInteger.isCombinable(newWidth))				newWidth = MesquiteInteger.queryInteger(this, "Set column width", "Column Width:", columnWidth, table.getMinColumnWidth(), table.getMaxColumnWidth() );			if (newWidth>=table.getMinColumnWidth() && newWidth<=table.getMaxColumnWidth() && newWidth!=columnWidth) {				table.doAutosize = false;				table.suppressAutosize = true;				table.setColumnWidthsUniform(columnWidth);				table.repaintAll();			}		}		else if (checker.compare(this.getClass(), "Sets whether or not cells of matrix are colored (no longer used)", "[on]", commandName, "toggleColorCell")) {			if ("on".equalsIgnoreCase(ParseUtil.getFirstToken(arguments, pos))) {				MesquiteModule mb = ownerModule.findEmployeeWithName("#ColorByState", true);				setCellColorer(mb);			}			table.repaintAll();		}		else if (checker.compare(this.getClass(), "Sets by what the cells in the matrix are colored", "[name of module]", commandName, "colorCells")) {			String s = ParseUtil.getFirstToken(arguments, pos);			int i = MesquiteInteger.fromFirstToken(arguments, pos);			if (MesquiteInteger.isCombinable(i)) {				ListableVector emp = ownerModule.getEmployeeVector();				Enumeration e=emp.elements();				int count = 0;				while (e.hasMoreElements()){					MesquiteModule mb = (MesquiteModule)e.nextElement();					if (mb instanceof CellColorer) {						if (count == i) {							if (mb == table.cellColorer) {								setCellColorer(null);							}							else {								setCellColorer(mb);							}							calculation();							return mb;						}						count++;					}				}			}			else {				MesquiteModule mb = (MesquiteModule)ownerModule.findEmployeeWithName(s, true);				if (mb instanceof CellColorer) { //note: if by name doesn't turn off!					setCellColorer(mb);					table.repaintAll();					return mb;				}			}		}		else if (checker.compare(this.getClass(), "Sets whether or not full names are shown in the cells of matrix", "[on or off]", commandName, "toggleShowNames")) {			table.showNames.toggleValue(ParseUtil.getFirstToken(arguments, pos));			table.doAutosize = true;			table.repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether or not birds eye view is shown", "[on or off]", commandName, "toggleshowBirdsEyeView")) {			table.showBirdsEyeView.toggleValue(ParseUtil.getFirstToken(arguments, pos));			if (table.showBirdsEyeView.getValue()) {				table.setColumnWidthsUniform(4);				table.frameMatrixCells = false;			}			else {				table.setColumnWidthsUniform(columnWidth);				table.frameMatrixCells = true;			}			table.repaintAll();		}		else if (checker.compare(this.getClass(), "Hires new data editor assistant module", "[name of module]", commandName, "newAssistant")) {			DataWindowAssistant dwa = (DataWindowAssistant)ownerModule.hireNamedEmployee(DataWindowAssistant.class, arguments);			dwa.setTableAndData(table, data); 		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	private void setCellColorer(MesquiteModule mb){		if (table.cellColorer != null)			table.cellColorer.setActiveColors(false);		table.cellColorer = (CellColorer)mb;		if (mb !=null) {			cellColorerName.setValue(mb.getName());			((CellColorer)mb).setActiveColors(true);		}		else {			cellColorerName.setValue((String)null);		}	}	/*.................................................................................................................*/	public void requestCellColorer(MesquiteModule mb, String message){		if (table.cellColorer == mb || table.textColorer == mb)			return;		if ((table.cellColorer == null && table.textColorer == null) || AlertDialog.query(this, "Cell colors", message, "Yes", "No")) {			setCellColorer(mb);			table.repaintAll();		}	}	/*.................................................................................................................*/	public void pleaseUpdate() {		table.repaintAll();	}	/*.................................................................................................................*/	/** passes which object changed, along with optional integer (e.g. for character) (from MesquiteListener interface)*/	public void changed(Object caller, Object obj, Notification notification){		int code = Notification.getCode(notification);		int[] parameters = Notification.getParameters(notification);		if (obj instanceof Taxa &&  (Taxa)obj ==data.getTaxa()) {			Taxa taxa = (Taxa)obj;			if (code==MesquiteListener.NAMES_CHANGED) {				calculation();				table.redrawRowNames();			}			else if (code==MesquiteListener.SELECTION_CHANGED) {				table.synchronizeRowSelection(taxa);				table.repaintAll();			}			else if (code==MesquiteListener.PARTS_ADDED) {				table.setNumRows(taxa.getNumTaxa());				table.synchronizeRowSelection(taxa);				calculation();				table.repaintAll();			}			else if (code==MesquiteListener.PARTS_DELETED) {				table.setNumRows(taxa.getNumTaxa());				table.synchronizeRowSelection(taxa);				calculation();				table.repaintAll();			}			else if (code==MesquiteListener.PARTS_MOVED) {				table.setNumRows(taxa.getNumTaxa());				table.synchronizeRowSelection(taxa);				calculation();				table.repaintAll();			}			else {				calculation();				table.repaintAll();			}			if (getMode()>0)				updateTextPage();		}		else if (obj instanceof CharacterData && (CharacterData)obj ==data) {			if (getMode()>0)				updateTextPage();			else if (code==MesquiteListener.NAMES_CHANGED) {				table.doAutosize = true;				calculation();				table.repaintAll();			}			else if (code==MesquiteListener.SELECTION_CHANGED) {				if (caller != table){    //if object provoking notification is me, then don't repaint					table.synchronizeColumnSelection(data);					table.repaintAll();				}			}			else if (code==MesquiteListener.PARTS_DELETED) {				table.doAutosize = true;				if (parameters!=null && parameters.length>1) {					int starting = parameters[0];					int num = parameters[1];					if (data.getNumChars()<table.getNumColumns()) {						for (int i = starting+num-1; i>=starting; i--)							table.deleteColumn(i);					}				}				else if (table.getNumColumns() != data.getNumChars())					table.setNumColumns(data.getNumChars());				if (table.getNumRows() != data.getTaxa().getNumTaxa())					table.setNumRows(data.getTaxa().getNumTaxa());				table.synchronizeColumnSelection(data);				calculation();				table.repaintAll();			}			else if (code==MesquiteListener.PARTS_ADDED) {				table.doAutosize = true;				if (parameters!=null && parameters.length>1) {					int starting = parameters[0];					int num = parameters[1];					if (data.getNumChars()>table.getNumColumns()) {						table.insertColumns(starting, num);					}				}				else if (table.getNumColumns() != data.getNumChars())					table.setNumColumns(data.getNumChars());				if (table.getNumRows() != data.getTaxa().getNumTaxa())					table.setNumRows(data.getTaxa().getNumTaxa());				table.synchronizeColumnSelection(data);				calculation();				table.repaintAll();			}			else if (code==MesquiteListener.PARTS_MOVED) {				table.doAutosize = true;				if (parameters!=null && parameters.length>1) {					int starting = parameters[0];					int num = parameters[1];					int justAfter = parameters[2];					if (data.getNumChars()==table.getNumColumns()) {						table.moveColumns(starting, num, justAfter);					}				}				if (table.getNumRows() != data.getTaxa().getNumTaxa())					table.setNumRows(data.getTaxa().getNumTaxa());				table.synchronizeColumnSelection(data);				calculation();				table.repaintAll();			}			else if (code==MesquiteListener.DATA_CHANGED) {				table.doAutosize = true;				if (table.getNumRows() != data.getTaxa().getNumTaxa())					table.setNumRows(data.getTaxa().getNumTaxa());				if (table.getNumColumns() != data.getNumChars())					table.setNumColumns(data.getNumChars());				table.synchronizeColumnSelection(data);				calculation();				table.repaintAll();			}			else{				table.doAutosize = true;				if (table.getNumRows() != data.getTaxa().getNumTaxa())					table.setNumRows(data.getTaxa().getNumTaxa());				if (table.getNumColumns() != data.getNumChars())					table.setNumColumns(data.getNumChars());				table.synchronizeColumnSelection(data);				calculation();				table.repaintAll();			}		}		table.setMessage(data.getCellContentsDescription());		super.changed(caller, obj, notification);	}	/*.................................................................................................................*/	/** calculation of column 1 and 2*/	public void calculation() {		Parser value = new Parser("0");		CharacterState recup = null;		data.setState(1,0,value,true,null);		value.setString(data.getCharacterState(recup,0,0).toString());		data.setState(2,0,value,true,null);		for(int it = 1; it<data.getNumTaxa(); it++) {			value.setString(data.getCharacterState(recup,2,it-1).toString());			data.setState(1,it,value,true,null);			value.setString(""+(MesquiteDouble.fromString(data.getCharacterState(recup,0,it).toString()) + MesquiteDouble.fromString(data.getCharacterState(recup,1,it).toString())));			data.setState(2,it,value,true,null);		}	}	public void updateTreeWindow() {		if(((NodeLocsPaleo)((ScaleDataWindowCoord)ownerModule.getEmployer()).getEmployer())!=null)			((NodeLocsPaleo)((ScaleDataWindowCoord)ownerModule.getEmployer()).getEmployer()).scaleChanged();		toFront();	}	/*.................................................................................................................*/	/** passes which object is being disposed (from MesquiteListener interface)*/	public void disposing(Object obj){		if ((obj instanceof Taxa &&  (Taxa)obj ==data.getTaxa())||(obj instanceof CharacterData && (CharacterData)obj ==data)) {			ownerModule.windowGoAway(this);		}	}	/*.................................................................................................................*/	/** passes which object is being disposed (from MesquiteListener interface)*/	public boolean okToDispose(Object obj, int queryUser){		return true;	}	/*.................................................................................................................*/	/** Query module as to whether conditions are such that it will have to quit soon -- e.g. if its taxa block has been doomed.  The tree window, data window, 	 etc. override this to return true if their object is doomed. This is useful in case MesquiteListener disposing method is not called for an employer before one of its	 employees discovers that it needs to quit.  If the employer is going to quit anyway,there is no use to use auto rehire for the quit employee.*/	public boolean quittingConditions(){		return (data.isDoomed() || data.getTaxa().isDoomed());		//return false;	}	/*.................................................................................................................*/	public void setWindowSize(int width, int height){		super.setWindowSize(width, height);		checkSizes();	}	void checkSizes(){		if (table !=null &&((getHeight()!=windowHeight) || (getWidth()!=windowWidth))) {			windowHeight =getHeight();			windowWidth = getWidth();			table.setSize(windowWidth, windowHeight);			table.doAutosize = true;		}	}	/*.................................................................................................................*/	public void setCurrentTool(MesquiteTool tool){		super.setCurrentTool(tool);		if ((getCurrentTool()!=ibeamTool) && (table!=null))			table.offAllEdits();		boolean myTool = (getCurrentTool()==ibeamTool || getCurrentTool()==arrowTool || getCurrentTool().getAllowAnnotate());		setAEFocusSuppression(!myTool);		if (!myTool)			table.requestFocus();	}	/*.................................................................................................................*/	public String getPrintMenuItem() {		return "Print Matrix...";	}	/*.................................................................................................................*/	public String getPrintToFitMenuItemName() {		return "Print Matrix To Fit Page...";	}	/** Returns menu location for item to bring the window to the for (0 = custom or don't show; 1 = system area of Windows menu; 2 = after system area of Windows menu)*/	public int getShowMenuLocation(){		return 0;	}	/*.................................................................................................................*/	public MesquiteTable getTable() {		return table; 	}	/*.................................................................................................................*/	public void printWindow(MesquitePrintJob pjob) {		table.printTable(pjob, this);		//TODO: optionally print modelsets, etc.	}	/*.................................................................................................................*/	public void paintContents(Graphics g) {		table.repaintAll();	}	/*.................................................................................................................*/	public String getTextContents() {		String s = "Scale Matrix Editor";		return s;	}	String getParameters(){		String s = "";		if (table.cellColorer!= null){			s += "Background of cells colored by: " + ((MesquiteModule)table.cellColorer).getName();		}		return s;	}	/*.................................................................................................................*/	public void windowResized(){		checkSizes();	}	public void dispose(){		disposing = true;		waitUntilDisposable();		table.dispose();		if (data.getTaxa()!=null)			data.getTaxa().removeListener(this);		if(palette!=null)			palette.dispose();		data.removeListener(this);		super.dispose();	}}class ScaleCellAnnotation implements Annotatable {	String name;	CharacterData data;	int row=-1;	int column = -1;	public ScaleCellAnnotation(CharacterData data) {		this.data = data;	}	int getRow(){		return row;	}	int getColumn(){		return column;	}	void setCell(int c, int r){		row = r;		column = c;	}	public String getName(){		if (data == null)			return "";		if (row == -1) {			if (column == -1)				return "matrix \"" + data.getName() + "\"";			return "Time \"" +data.getCharacterName(column) + "\"";		}		else if (column == -1) {			return "Period \"" +data.getTaxa().getTaxonName(row) + "\"";		}		else {			return "Time " + (column +1) + " of Period " + (row+1);		}	}	public String getAnnotation(){		if (data == null)			return null;		if (row == -1) {			if (column == -1)				return data.getAnnotation();			return data.getAnnotation(column);		}		else if (column == -1) {			return data.getTaxa().getAnnotation(row);		}		else {			return data.getAnnotation(column, row);		}	}	public void setAnnotation(String s, boolean notify){		if (data == null)			return;		if ("".equals(s))			s = null;		if (row == -1) {			if (column == -1) {				data.setAnnotation(s, notify);				return;			}			data.setAnnotation(column, s);		}		else if (column == -1) {			data.getTaxa().setAnnotation(row, s);		}		else {			data.setAnnotation(column, row, s);		}	}}/* ======================================================================== */class ScaleDataWindowPalette extends ToolPalette {	public ScaleDataWindowPalette(ScaleDataWindowMaker ownerModule, ScaleDataWindow containingWindow) {  //in future pass general MesquiteWindow		super( ownerModule,  containingWindow, 1);	}}/* ======================================================================== */class ScaleMatrixTable extends MesquiteTable {	ScaleDataWindowMaker editorModule;	Taxa taxa;	MesquiteBoolean showStates;	MesquiteBoolean autoWithCharNames;	MesquiteBoolean showNames;	MesquiteBoolean showBirdsEyeView;	MesquiteBoolean tight;	MesquiteBoolean showChanges;	MesquiteBoolean statesSeparateLines;	ScaleCellAnnotation cellAnnotated;	CharacterData data;	Font oldFont=null;	Font boldFont;	Parser parser = new Parser();	ScaleDataWindow window;	CellColorer cellColorer = null;	CellColorer textColorer = null;	Color bgColor = Color.white;	ScaleButtonUpdate buttonUpdate;	public ScaleMatrixTable (ScaleDataWindowMaker editorModule,  ScaleDataWindow window, CharacterData data, int numRowsTotal, int numColumnsTotal, int totalWidth, int totalHeight, int taxonNamesWidth) {		super(numRowsTotal, numColumnsTotal, totalWidth, totalHeight, taxonNamesWidth, ColorDistribution.getColorScheme(editorModule),true,true);		this.window = window;		setUserMove(true, true); 		this.data = data;		cellAnnotated = new ScaleCellAnnotation(data);		showStates = new MesquiteBoolean(true);		autoWithCharNames = new MesquiteBoolean(true);		showBirdsEyeView = new MesquiteBoolean(false);		tight = new MesquiteBoolean(false);		showChanges = new MesquiteBoolean(true);		showNames = new MesquiteBoolean(true);		statesSeparateLines = new MesquiteBoolean(false);		setUserAdjust(MesquiteTable.NOADJUST, MesquiteTable.RESIZE);		showRowGrabbers=true;		showColumnGrabbers=true;		setEditable(true, true, false, false);		setSelectable(true, true, true, true, false, false);		this.editorModule=editorModule;		this.taxa = data.getTaxa();		setMessage(data.getCellContentsDescription());		setBackground(ColorTheme.getInterfaceBackgroundPale());		oldFont = getFont();		if (oldFont!=null)			boldFont = new Font(oldFont.getName(), Font.BOLD, oldFont.getSize());		synchronizeRowSelection(taxa);		synchronizeColumnSelection(data);		buttonUpdate = new ScaleButtonUpdate(window, this.cornerCell);	}	/*.................................................................................................................*/	/** A request for the MesquiteModule to perform a command.  It is passed two strings, the name of the command and the arguments.	 This should be overridden by any module that wants to respond to a command.*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) { 		if  (checker.compare(MesquiteTable.class, "Paste contents of clipboard into matrix", null, commandName, "paste")) {			if (window.annotationHasFocus()){				return  super.doCommand(commandName, arguments, checker);			}			Clipboard clip = Toolkit.getDefaultToolkit().getSystemClipboard();			Transferable t = clip.getContents(this);			try {				String s = (String)t.getTransferData(DataFlavor.stringFlavor);				if (s!=null) {					if (matrix.getEditing()|| rowNames.getEditing() || columnNames.getEditing()){						TextField edit = null;						if (matrix.getEditing())							edit = matrix.getEditField();						else if (rowNames.getEditing())							edit = rowNames.getEditField();						else if (columnNames.getEditing())							edit = columnNames.getEditField();						if (edit!=null) {							String text = edit.getText();							String newText = text.substring(0, edit.getSelectionStart()) + s + text.substring(edit.getSelectionEnd(), text.length());							edit.setText(newText);						}					}					else if (clipboardDimensionsFit(s)){						data.incrementNotifySuppress();						pasteIt(s);						deselectAll();						data.notifyListeners(this, new Notification(MesquiteListener.DATA_CHANGED));						data.decrementNotifySuppress();						repaintAll();					}					else {						int[] lines = getTabbedLines(s); 						if (lines==null || lines.length==0 || lines[0]==0) {							editorModule.alert("Sorry, the pasted text was not appropriate for the matrix.");							return null;						}						if (!IntegerArray.equalValues(lines)) {							if (AlertDialog.query(editorModule.containerOfModule(), "Paste shape mismatch", "Sorry, the number of lines and of items pasted don't match the spaces selected to be filled.  Would you like Mesquite to attempt to adjust the selected region so that you can paste?  (Note: if you select OK, Mesquite will change the selection but will not paste. You will have to request again to paste.)", "OK", "Cancel", 1))								setSelectionToShape(lines);						}						else {							if (AlertDialog.query(editorModule.containerOfModule(), "Paste shape mismatch", "Sorry, Clipboard is a different size or shape than the region selected, and thus you cannot paste.  Would you like Mesquite to attempt to adjust the selected region so that you can paste?  (Note: if you select OK, Mesquite will change the selection but will not paste. You will have to request again to paste.)", "OK", "Cancel", 1))								setSelectionToShape(lines);						}					}				}			}			catch(Exception e){				e.printStackTrace();			}		}		else return  super.doCommand(commandName, arguments, checker);		return null;	}	public boolean autoSizeColumns (Graphics g) {		FontMetrics fm=g.getFontMetrics(g.getFont());		int h = fm.getMaxAscent()+ fm.getMaxDescent() + MesquiteModule.textEdgeCompensationHeight; //2 + MesquiteString.riseOffset;		setRowHeightsUniform(h);		setColumnNamesRowHeight(h);		String s;		int tableWIDTHpart =getTableWidth()/3 ;		boolean changed = false;		int def = fm.stringWidth("G"); //WPMMAT 12		int max = def;		for (int ic = 0; ic<data.getNumChars(); ic++) {			setColumnWidth(ic, window.columnWidth);		}		return changed;	}	/*...............................................................................................................*/	public String getCornerText(){  		return "Period  \\  Dates";	}	/*...............................................................................................................*/	/** sets which row is the first visible.*/	public void setFirstRowVisible (int value) {		super.setFirstRowVisible(value);		window.setExplanation("Time " + (getFirstColumnVisible()+1) + " to " + (getLastColumnVisible()+1) + "; Period " + + (getFirstRowVisible()+1) + " to " + (getLastRowVisible()+1));	}	/*...............................................................................................................*/	/** sets which column is the first visible.*/	public void setFirstColumnVisible (int value) {		super.setFirstColumnVisible(value);		window.setExplanation("Time " + (getFirstColumnVisible()+1) + " to " + (getLastColumnVisible()+1) + "; Period " + + (getFirstRowVisible()+1) + " to " + (getLastRowVisible()+1));	}	/*...............................................................................................................*/	/** returns color of row or number box. */	public Color getRowNumberBoxColor(boolean isRow, int number) {		Color color = null;		if (!isRow)			color = data.getDefaultCharacterColor(number);		if (color!=null)			return color;		else if (!isRow)			return Color.lightGray;		return ColorTheme.getInterfaceElement();	}	/*...............................................................................................................*/	/** returns dark color of row or number box. */	public Color getRowNumberBoxDarkColor(boolean isRow, int number) {		Color color = null;		if (!isRow)			color = data.getDarkDefaultCharacterColor(number);		if (color!=null)			return color;		return ColorTheme.getInterfaceElementContrast();	}	/*...............................................................................................................*/	float[] hsb = new float[3];	NameReference notesNameRef = NameReference.getNameReference("notes");	private boolean isAnnotAvail(int column, int row){		if (data == null)			return false;		AttachedNotesVector anv = null;		if (column<0) 			anv = (AttachedNotesVector)data.getTaxa().getAssociatedObject(notesNameRef, row);		else if (row < 0)			anv = (AttachedNotesVector)data.getAssociatedObject(notesNameRef, column);		else 			anv = (AttachedNotesVector)data.getCellObject(notesNameRef, column, row);		if (anv == null)			return false;		return (anv.getNumNotes()>0);	}	// TODO	private int automaticColor = 0; // Create cells with differents colors by default (10/05)	private int autoColor() {		automaticColor++;		if(automaticColor == 4) automaticColor = 5;		else if (automaticColor == 18) automaticColor = 0;		return automaticColor;	}	MesquiteBoolean overflow = new MesquiteBoolean(false);	public void drawMatrixCell(Graphics g, int x, int y, int w, int h, int column, int row, boolean selected){		if (data == null)			return;		NameReference nr = NameReference.getNameReference("color");		MesquiteInteger ms = new MesquiteInteger(autoColor()); // Create cells with differents colors by default (10/05)		if(data.getCellObject(nr,column,row) == null) {			data.setCellObject(nr,column,row,ms);			data.setCellObject(nr,-1,row,ms); // to fix bug (10/05)		}		boolean writeStates = !showBirdsEyeView.getValue() && showStates.getValue();		boolean leaveEdges = writeStates && !tight.getValue();		boolean changedSinceSave = showChanges.getValue() && data.getChangedSinceSave(column, row);		boolean annotationAvailable = isAnnotAvail(column, row);		Color c = g.getColor();		hsb[0]=hsb[1]=hsb[2]= 1;		Color fillColor = null;		if (selected){			fillColor = Color.black;		}		else if (cellColorer !=null) {			fillColor = cellColorer.getCellColor(column, row);		}		if (fillColor == null)			fillColor = bgColor;		Color.RGBtoHSB(fillColor.getRed(), fillColor.getGreen(), fillColor.getBlue(), hsb);		g.setColor(fillColor);		if (leaveEdges)			g.fillRect(x+1,y+1,w-1, h-1);		else			g.fillRect(x,y,w, h);		if (writeStates) {			if (changedSinceSave){				g.setColor(getContrasting(selected, hsb, Color.lightGray, Color.darkGray));				g.drawLine(x,y+1, x+1,y);				g.drawLine(x,y+2, x+2,y);				g.drawLine(x,y+3, x+3,y);			}			if (annotationAvailable){				g.setColor(getContrasting(selected, hsb, Color.white, Color.black));				g.drawLine(x+w-2,y+1, x+w-2,y+2); //left				g.drawLine(x+w-2,y+2, x+w,y+2); //bottom				g.drawLine(x+w,y+1, x+w,y+2); //right				g.drawLine(x+w-2,y, x+w,y); //top				if (!selected){					g.setColor(Color.white);					g.drawLine(x+w-1,y+1, x+w-1,y+1);				}			}			Color textColor = null;			if (textColorer !=null)				textColor = textColorer.getCellColor(column, row);			if (textColor == null){				textColor = getContrasting(selected, hsb, Color.white, Color.black);			}			g.setColor(textColor);			String st = getMatrixTextForDisplay(column, row);			overflow.setValue(false);			int cent = StringUtil.getStringCenterPosition(st,g,x,w, overflow);			boolean useClip = overflow.getValue();			int vert = StringUtil.getStringVertPosition(g,y,h, overflow);			useClip |= overflow.getValue();			Shape clip = null;			if (useClip) {				clip = g.getClip();				g.setClip(x, y, w, h);			}			g.drawString(st, cent, vert);			if (useClip) {				g.setClip(clip);			}		}		if (c!=null) g.setColor(c);	}	/*...............................................................................................................*/	Color getContrasting(boolean selected, float[] hsb, Color light, Color dark){		if (selected)			return light;		else if (hsb[2]>0.5)			return dark;		else			return light;	}	/*...............................................................................................................*/	public  boolean useString(int column, int row){		return false;	}	/*...............................................................................................................*/	public void drawColumnNameCell(Graphics g, int x, int y, int w, int h, int column){		if (data == null)			return;		boolean annotationAvailable = isAnnotAvail(column, -1);		Color fillColor = null;		boolean selected = isColumnNameSelectedAnyWay(column);		if (selected){			fillColor = Color.black;		}		else if (cellColorer !=null) {			fillColor = cellColorer.getCellColor(column, -1);		}		if (fillColor == null) {			CharacterPartition part = (CharacterPartition)data.getCurrentSpecsSet(CharacterPartition.class);			if (part!=null){				CharactersGroup mi = (CharactersGroup)part.getProperty(column);				if (mi!=null)					fillColor = mi.getColor();			}		}		if (fillColor == null)			fillColor = bgColor;		if (fillColor != null){			Color c = g.getColor();			g.setColor(fillColor);			g.fillRect(x+1,y+1,w-1,h-1);			if (c!=null) g.setColor(c);		}		hsb[0]=hsb[1]=hsb[2]= 1;		Color.RGBtoHSB(fillColor.getRed(), fillColor.getGreen(), fillColor.getBlue(), hsb);		Color oldColor = null;		if (annotationAvailable){			oldColor = g.getColor();			g.setColor(getContrasting(selected, hsb, Color.white, Color.black));			g.drawLine(x+w-2,y+1, x+w-2,y+2); //left			g.drawLine(x+w-2,y+2, x+w,y+2); //bottom			g.drawLine(x+w,y+1, x+w,y+2); //right			g.drawLine(x+w-2,y, x+w,y); //top			if (!selected){				g.setColor(Color.white);				g.drawLine(x+w-1,y+1, x+w-1,y+1);			}			g.setColor(oldColor);		}		if (selected){			g.setColor(Color.white);		}		oldColor = g.getColor();		Color textColor = null;		if (textColorer !=null)			textColor = textColorer.getCellColor(column, -1);		if (textColor == null){			textColor = getContrasting(selected, hsb, Color.white, Color.black);		}		g.setColor(textColor);		String name;		if (data.characterHasName(column))			name = data.getCharacterName(column);		else			name = Integer.toString(CharacterStates.toExternal(column));		String s = data.getAnnotation(column);		if (!StringUtil.blank(s)) 			name = "*" + name;		g.drawString(name, x+getNameStartOffset(), StringUtil.getStringVertPosition(g,y,h, null));		g.setColor(oldColor);	}	/*...............................................................................................................*/	public void drawRowNameCell(Graphics g, int x, int y,  int w, int h, int row){		if (taxa == null)			return;		Color fillColor = null;		boolean annotationAvailable = isAnnotAvail(-1, row);		boolean selected = isRowNameSelectedAnyWay(row);		if (selected){			fillColor = Color.black;		}		else if (cellColorer !=null) {			fillColor = cellColorer.getCellColor(-1, row);		}		if (fillColor == null)  {			TaxaPartition part = (TaxaPartition)taxa.getCurrentSpecsSet(TaxaPartition.class);			if (part!=null){				TaxaGroup mi = (TaxaGroup)part.getProperty(row);				if (mi!=null)					fillColor = mi.getColor();			}		}		if (fillColor == null)			fillColor = bgColor;		if (fillColor != null){			Color c = g.getColor();			g.setColor(fillColor);			g.fillRect(x+1,y+1,w-1,h-1);			if (c!=null) g.setColor(c);		}		hsb[0]=hsb[1]=hsb[2]= 1;		Color.RGBtoHSB(fillColor.getRed(), fillColor.getGreen(), fillColor.getBlue(), hsb);		Color oldColor = null;		if (annotationAvailable){			oldColor = g.getColor();			g.setColor(getContrasting(selected, hsb, Color.white, Color.black));			g.drawLine(x+w-3,y+1, x+w-3,y+2); //left			g.drawLine(x+w-3,y+2, x+w-1,y+2); //bottom			g.drawLine(x+w-1,y+1, x+w-1,y+2); //right			g.drawLine(x+w-3,y, x+w-1,y); //top			if (!selected){				g.setColor(Color.white);				g.drawLine(x+w-2,y+1, x+w-2,y+1);			}			g.setColor(oldColor);		}		oldColor = g.getColor();		Color textColor = null;		if (textColorer !=null)			textColor = textColorer.getCellColor(-1, row);		if (textColor == null){			textColor = getContrasting(selected, hsb, Color.white, Color.black);		}		g.setColor(textColor);		String s = taxa.getAnnotation(row);		int svp = StringUtil.getStringVertPosition(g,y,h, null);		int xgnso = x+getNameStartOffset();		if (!StringUtil.blank(s)) 			g.drawString("*" + taxa.getTaxon(row).getName(), xgnso, svp);		else			g.drawString(taxa.getTaxon(row).getName(), xgnso, svp);		g.setColor(oldColor);	}	Color distinguishTextColor(Graphics g, Color bg){		Color current = g.getColor();		if (current.equals(bg)){			if (current.equals(Color.black))				g.setColor(Color.white);			else				g.setColor(Color.black);			return current;		}		return null;	}	StringBuffer sb = new StringBuffer(50);	/*...............................................................................................................*/	public String getMatrixText(int column, int row){		sb.setLength(0);		data.statesIntoStringBuffer(column,row, sb, false);		return sb.toString();	}	boolean displayModifications = false;	private boolean checkDisplayModifications(){		//go through all assistants to see if they claim hasDisplayModifications		Enumeration e=window.ownerModule.getEmployeeVector().elements();		while (e.hasMoreElements()){			Object obj = e.nextElement();			if (obj instanceof DataWindowAssistant) {				DataWindowAssistant init = (DataWindowAssistant)obj;				if (init.hasDisplayModifications()) {					return true;				}			}		}		return false;	}	/*...............................................................................................................*/	public String getMatrixTextForDisplay(int column, int row){		sb.setLength(0);		data.statesIntoStringBuffer(column,row, sb, showNames.getValue());		if (!StringUtil.blank(data.getAnnotation(column, row))) {			sb.append('*');		}		if (displayModifications){			if (data.getCellObjectDisplay(column, row)) {				//go through assistants that claim to have modifications to see what each wants to add				Enumeration e=window.ownerModule.getEmployeeVector().elements();				while (e.hasMoreElements()){					Object obj = e.nextElement();					if (obj instanceof DataWindowAssistant) {						DataWindowAssistant init = (DataWindowAssistant)obj;						if (init.hasDisplayModifications()) {							String s = init.getDisplayModString(column, row);							if (s!=null)								sb.append(s);						}					}				}			}		}		return sb.toString();	}	/*.................................................................................................................*/	public String getColumnComment(int column) {		return data.getAnnotation(column);	}	/*.................................................................................................................*/	public String getRowComment(int row) {		return taxa.getAnnotation(row);	}	/*...............................................................................................................*/	/** Returns text in row name.  */	public String getRowNameText(int row){		Taxon t = taxa.getTaxon(row);		if (t!=null) {			return t.getName();		}		else			return "";	}	/*...............................................................................................................*/	/** Returns text in column name.  */	public String getColumnNameText(int column){		return data.getCharacterName(column);	}	/*...............................................................................................................*/	/** Returns text in column name.  */	public String getColumnNameTextForDisplay(int column){		if (data.characterHasName(column))			return data.getCharacterName(column);		else			return Integer.toString(CharacterStates.toExternal(column));	}	/*...............................................................................................................*/	StringBuffer esb = new StringBuffer(100);	String getCellExplanation(int column, int row){		String s = "[";		if (row>=0 && row<data.getNumTaxa())			s += "t." + (row+1);		if (column>=0 && column<data.getNumChars())			s += " c." + (column+1);		if (row>=0 && row<data.getNumTaxa() && column>=0 && column<data.getNumChars()){			esb.setLength(0);			data.statesIntoStringBuffer(column,row, esb, false);			s += " s." + esb;		}		s += "] ";		if (column>=0)			s += data.getCharacterName(column) + statesExplanation(column, row);		if (row>=0 && row<data.getNumTaxa() && column>=0)			s += " [in Period \"" + data.getTaxa().getTaxonName(row) + "\"]";		return s;	}	public void setFocusedCell(int column, int row){		//super.setFocusedCell(column, row);		cellAnnotated.setCell(column, row);		window.setAnnotation(cellAnnotated);		window.setExplanation(getCellExplanation(column, row));		if ((window.getCurrentTool()== window.arrowTool) && (isEditing(column, row))) {			window.setCurrentTool(window.ibeamTool);			window.getPalette().setCurrentTool(window.ibeamTool); 		}	}	/*...............................................................................................................*/	public void cellTouched(int column, int row, int regionInCellH, int regionInCellV, int modifiers, int clickCount) {		if(column == 1 || column == 2 || row == -1) return;		if ((window.getCurrentTool()== window.arrowTool) && (clickCount>1)) {			window.setCurrentTool(window.ibeamTool);			window.getPalette().setCurrentTool(window.ibeamTool); 			((TableTool)window.getCurrentTool()).cellTouched(column, row, regionInCellH, regionInCellV, modifiers);		}		else if (((TableTool)window.getCurrentTool()).useTableTouchRules()) {			super.cellTouched(column, row, regionInCellH, regionInCellV, modifiers, clickCount);		}		else {			((TableTool)window.getCurrentTool()).cellTouched(column, row, regionInCellH, regionInCellV, modifiers);		}		if (window.getCurrentTool()== window.arrowTool || window.getCurrentTool()== window.ibeamTool || window.getCurrentTool().getAllowAnnotate() || ((TableTool)window.getCurrentTool()).useTableTouchRules()){			setFocusedCell(column, row);		}		else			window.setAnnotation("", null);	}	/*...............................................................................................................*/	public void cellDrag(int column, int row, int regionInCellH, int regionInCellV, int modifiers) {		if (((TableTool)window.getCurrentTool()).useTableTouchRules()) 			super.cellDrag(column, row, regionInCellH,  regionInCellV, modifiers);		else			((TableTool)window.getCurrentTool()).cellDrag(column, row, regionInCellH,  regionInCellV, modifiers);	}	/*...............................................................................................................*/	public void cellDropped(int column, int row, int regionInCellH, int regionInCellV, int modifiers) {		if (((TableTool)window.getCurrentTool()).useTableTouchRules())			super.cellDropped(column, row, regionInCellH, regionInCellV, modifiers);		else			((TableTool)window.getCurrentTool()).cellDropped(column, row, regionInCellH, regionInCellV, modifiers);	}	/*...............................................................................................................*/	private void checkTouchCurrentCell(int oldColumn, int oldRow){		if (((TableTool)window.getCurrentTool()).getTouchOnArrowKey()){			if (singleTableCellSelected()) {				Dimension sel = getFirstTableCellSelected();				if (oldColumn != sel.width || oldRow != sel.height){					((TableTool)window.getCurrentTool()).cellTouched(sel.width, sel.height, 50, 50, 0);				}			}		}	}	/*...............................................................................................................*/	public void downArrowPressed(String arguments){		Dimension sel = getFirstTableCellSelected();		super.downArrowPressed(arguments);		checkTouchCurrentCell(sel.width, sel.height);	}	/*...............................................................................................................*/	public void upArrowPressed(String arguments){		Dimension sel = getFirstTableCellSelected();		super.upArrowPressed(arguments);		checkTouchCurrentCell(sel.width, sel.height);	}	/*...............................................................................................................*/	public void rightArrowPressed(String arguments){		Dimension sel = getFirstTableCellSelected();		super.rightArrowPressed(arguments);		checkTouchCurrentCell(sel.width, sel.height);	}	/*...............................................................................................................*/	public void leftArrowPressed(String arguments){		Dimension sel = getFirstTableCellSelected();		super.leftArrowPressed(arguments);		checkTouchCurrentCell(sel.width, sel.height);	}	/*...............................................................................................................*/	public void rowNameTouched(int row, int regionInCellH, int regionInCellV, int modifiers, int clickCount) {		if (window.getCurrentTool()== window.arrowTool || window.getCurrentTool()== window.ibeamTool || window.getCurrentTool().getAllowAnnotate()){			cellAnnotated.setCell(-1, row);			window.setAnnotation(cellAnnotated);		}		else			window.setAnnotation("", null);		if (window.getCurrentTool()== window.arrowTool) 			if (clickCount>1){				window.setCurrentTool(window.ibeamTool); 				window.getPalette().setCurrentTool(window.ibeamTool); 				((TableTool)window.getCurrentTool()).cellTouched(-1, row, regionInCellH, regionInCellV, modifiers);			}			else				super.rowNameTouched( row, regionInCellH, regionInCellV, modifiers, clickCount);		else			((TableTool)window.getCurrentTool()).cellTouched(-1, row, regionInCellH, regionInCellV, modifiers); 	}	/*...............................................................................................................*/	public void rowTouched(boolean asArrow, int row, int regionInCellH, int regionInCellV, int modifiers) {		if (((TableTool)window.getCurrentTool()).useTableTouchRules())			super.rowTouched(asArrow, row, regionInCellH, regionInCellV, modifiers);		else			((TableTool)window.getCurrentTool()).cellTouched(-1, row, regionInCellH, regionInCellV, modifiers); 	}	/*...............................................................................................................*/	private String statesExplanation(int column,int row){		return "";	}	/*...............................................................................................................*/	public void mouseInCell(int modifiers, int column,int row, MesquiteTool tool){		if (column>=0 && column <= data.getNumChars() && !(matrix.getEditing()|| rowNames.getEditing() || columnNames.getEditing()) && !singleTableCellSelected()) {			window.setExplanation(getCellExplanation(column, row));		}	}	/*...............................................................................................................*/	public void columnNameTouched(int column, int regionInCellH, int regionInCellV, int modifiers, int clickCount) {		if (window.getCurrentTool()== window.arrowTool || window.getCurrentTool()== window.ibeamTool || window.getCurrentTool().getAllowAnnotate()){			cellAnnotated.setCell(column, -1);			window.setAnnotation(cellAnnotated);		}		else			window.setAnnotation("", null);		if (window.getCurrentTool()== window.arrowTool) {			if (clickCount>1){				window.setCurrentTool(window.ibeamTool); 				window.getPalette().setCurrentTool(window.ibeamTool);				((TableTool)window.getCurrentTool()).cellTouched(column, -1, regionInCellH, regionInCellV, modifiers);			}			else				super.columnNameTouched( column, regionInCellH, regionInCellV, modifiers, clickCount);		}		else {			((TableTool)window.getCurrentTool()).cellTouched(column, -1, regionInCellH, regionInCellV, modifiers);		}	}	/*...............................................................................................................*/	public void columnTouched(boolean asArrow, int column, int regionInCellH, int regionInCellV, int modifiers) {		if (((TableTool)window.getCurrentTool()).useTableTouchRules()) {			super.columnTouched(asArrow, column, regionInCellH, regionInCellV, modifiers);		}		else {			((TableTool)window.getCurrentTool()).cellTouched(column, -1, regionInCellH, regionInCellV, modifiers);		}	}	/*...............................................................................................................*/	public void moveOneColumn(int column, int after){		int width = getColumnWidth(column);		if (column<after) {			for (int i=column; i<after; i++) {				setColumnWidth(i,getColumnWidth(i+1));				if (isColumnSelected(i+1))					selectColumn(i);				else					deselectColumn(i);			}			setColumnWidth(after,width);		} 		else if (column>after) {			for (int i=column; i>after+1; i--)				setColumnWidth(i,getColumnWidth(i-1));			setColumnWidth(after+1,width);		} 		data.moveParts(column,1,after);//TODO: not correct! need to adjust and see what new "after" is		data.moveInLinked(column, 1, after, false);	}	/*...............................................................................................................*/	public void moveColumns(int starting, int num, int justAfter){		//todo: check for illegal move		if (justAfter<starting) { //moving columns left, closer to zero			for (int i=starting; i<starting+num-1; i++)				moveOneColumn(i,justAfter++);//after each move, starting is now one column on		} 		else {//moving columns right			for (int i=0; i<num; i++) 				moveOneColumn(starting,justAfter);  //after each move, starting is now column moved up, and justafter has moved up		}		synchronizeColumnSelection(data);		data.notifyListeners(this, new Notification(MesquiteListener.PARTS_MOVED));		data.notifyInLinked(new Notification(MesquiteListener.PARTS_MOVED));		editorModule.getModuleWindow().contentsChanged();	}	/*...............................................................................................................*/	public void moveOneRow(int row, int after){		taxa.moveParts(row,1,after);	}	/*............................................................................................................*/	/** Called if row was dragged and dropped. 	 (after = -1 if dropped above first row; -2 if below last.)*/	public void selectedRowsDropped(int after) {		if (after < -1)			return;		if (after > getNumRows())			after = getNumRows();		int i = 0;		Bits sel = getRowsSelected();		while (i<getNumRows()) {			if (sel.isBitOn(i)) {				deselectRow(i);				sel.clearBit(i);				moveOneRow(i,after);				sel.moveParts(i, 1, after);				if (i>after)					after++;				i=0;			}			else				i++;		}		synchronizeRowSelection(data);		taxa.notifyListeners(this, new Notification(MesquiteListener.PARTS_MOVED));		editorModule.getModuleWindow().contentsChanged();	}	/*...............................................................................................................*/	public void selectedColumnsDropped(int after){	}	/*...............................................................................................................*/	boolean doAutosize = false;	boolean suppressAutosize = false;	/*.................................................................................................................*/	protected void clearIt(boolean cut){		for (int i = 0; i<numColumnsTotal; i++) {			if (isColumnNameSelected(i) || isColumnSelected(i)) {				returnedColumnNameText(i,"");			}		}		for (int j = 0; j<numRowsTotal; j++) {			if (isRowNameSelected(j) || isRowSelected(j)) {				returnedRowNameText(j,"");			}			for (int i = 0; i<numColumnsTotal; i++) {				if (isCellSelected(i,j) || isRowSelected(j) || isColumnSelected(i)) {					returnedMatrixText(i,j,"?");				}			}		}		if (cut){			deleteSelected();		}	}	private void deleteSelected(){		if (data !=null){			if (anyColumnSelected()) {				if (!MesquiteThread.isScripting() && !AlertDialog.query(window, "Delete characters?","The data for the selected characters have been cleared.  Do you also want to delete the selected characters?", "Yes", "No"))					return;				Vector blocks = new Vector();				while(anyColumnSelected()){					int lastOfBlock = lastColumnSelected();					int firstOfBlock = startOfLastColumnBlockSelected();					if (lastOfBlock>=0){						for (int i=firstOfBlock; i<=lastOfBlock; i++)							deselectColumn(i);						data.deleteParts(firstOfBlock,lastOfBlock-firstOfBlock+1);						data.deleteInLinked(firstOfBlock,lastOfBlock-firstOfBlock+1, false); 						blocks.addElement( new int[] {firstOfBlock,lastOfBlock-firstOfBlock+1});  //do as series of contiguous blocks					}				}				for (int i=0; i<blocks.size(); i++) {					data.notifyListeners(this, new Notification(MesquiteListener.PARTS_DELETED, (int[])blocks.elementAt(i)));  //do as series of contiguous blocks					data.notifyInLinked(new Notification(MesquiteListener.PARTS_DELETED, (int[])blocks.elementAt(i)));  //do as series of contiguous blocks				}			}			if (anyRowSelected()) {				Bits rows = getRowsSelected();				if (rows.numBitsOn() == data.getTaxa().getNumTaxa()){					window.ownerModule.discreetAlert( "You cannot delete all of the taxa; the data will be cleared but the taxa will remain.");					return;				}				if (!MesquiteThread.isScripting() && !AlertDialog.query(window, "Delete period?","The data for the selected period have been cleared.  Do you also want to delete the selected period?", "Yes", "No"))					return;				for (int i=getNumRows()-1; i>=0; i--){					if (rows.isBitOn(i)) {						data.getTaxa().deleteTaxa(i,1, false);					}				}				Notification nn;				data.getTaxa().notifyListeners(this, nn = new Notification(MesquiteListener.PARTS_DELETED));//do as series of contiguous blocks				data.notifyListeners(this, new Notification(MesquiteListener.PARTS_CHANGED).setNotificationNumber(nn.getNotificationNumber()));//do as series of contiguous blocks			}		}	}	boolean turnOffWarnings = false;	/*...............................................................................................................*/	public void returnedMatrixText(int column, int row, String s){ //TODO: SHOULD CHECK FOR ERRORS		if (window == null || window.ownerModule == null || window.ownerModule.isDoomed() || StringUtil.blank(s))			return;		CharacterState csBefore = data.getCharacterState(null, column,row);		parser.setString(s);		MesquiteString result = new MesquiteString("");		int response = data.setState(column, row, parser, true, result); //receive errors?		if (response == CharacterData.OK){			CharacterState csAfter = data.getCharacterState(null, column,row);			if (csBefore !=null && !csBefore.equals(csAfter)) {				data.notifyListeners(this, new Notification(MesquiteListener.DATA_CHANGED, new int[] {column, row}));				doAutosize = true;			}		}		else if (!result.isBlank()) {			String ws = "Illegal entry for time " + (column+1) + " in period "  + (row+1) + ": " + result.toString();			if (turnOffWarnings || MesquiteThread.isScripting())				window.ownerModule.logln(ws);			else				turnOffWarnings = !AlertDialog.query(window, "Illegal character state",  ws, "OK", "Don't warn again");		}	}	/*...............................................................................................................*/	public void returnedRowNameText(int row, String s){		if (s!=null && !s.equals(taxa.getTaxonName(row))) {			String warning = taxa.checkNameLegality(row, s);			if (warning == null)				taxa.setTaxonName(row, s);			else				window.ownerModule.discreetAlert( warning);		}	}	/*...............................................................................................................*/	public void returnedColumnNameText(int column, String s){		if (s!=null && !s.equals(data.getCharacterName(column))) {			data.setCharacterName(column, data.getCharacterName(column));		}	}	/*...............................................................................................................*/	public int getMinColumnWidth(){		return 3;	}	public void repaintAll(){		displayModifications = checkDisplayModifications();		if (data !=null)			data.checkTaxaIDs(); //seeing that taxa id's still OK!		super.repaintAll();	}	/*...............................................................................................................*/	public void paint(Graphics g) {		if (MesquiteWindow.checkDoomed(this))			return;		displayModifications = checkDisplayModifications();		Font gF = g.getFont();		boolean resized = false;		if (oldFont == null || !gF.equals(oldFont)) {			if ((data.pleaseAutoSizeColumns()) && !showBirdsEyeView.getValue()) //TODO: 				resized =autoSizeColumns(g);			oldFont = g.getFont();			boldFont = new Font(oldFont.getName(), Font.BOLD, oldFont.getSize());		}		else if (doAutosize && !suppressAutosize) {			doAutosize = false;			resized =autoSizeColumns(g);		}		if (resized) {			MesquiteWindow.uncheckDoomed(this);			resetComponentSizes();			repaintAll();		}		else {			super.paint(g);			MesquiteWindow.uncheckDoomed(this);		}	}	/*...............................................................................................................*/}class ScaleButtonUpdate extends Panel implements java.awt.event.ActionListener {	Button update;	ScaleDataWindow ownerModule;	CornerPanel ownerPanel;	public ScaleButtonUpdate(ScaleDataWindow ownerModule, CornerPanel ownerPanel) {		super();		this.ownerModule = ownerModule;		this.ownerPanel = ownerPanel;		ownerPanel.add(this);		setSize(130,30);		setBackground(ownerPanel.getBackground());		setLayout(null);		setLocation(100,5);		setVisible(true);		update = new Button();		add(update);		update.addActionListener(this);		update.setBackground(ownerPanel.getBackground());		if(!ownerPanel.getBackground().equals(Color.blue))			update.setForeground(Color.blue);		else			update.setForeground(Color.white);		//update.setSize(getWidth()-5,getWidth()-5);		update.setSize(121,19);		update.setLocation(6,6);		update.setLabel("Update Tree Window");		update.setVisible(true);	}	public void actionPerformed(java.awt.event.ActionEvent evt) {		Object source = evt.getSource();		if(source == update){			ownerModule.calculation();			ownerModule.updateTreeWindow();		}	}	public void paint(Graphics g) {		if (MesquiteWindow.checkDoomed(this))			return;		Color c = g.getColor();		if(!ownerPanel.getBackground().equals(Color.blue))			g.setColor(Color.blue);		else			g.setColor(Color.white);		g.drawRoundRect(2,2,127,26,10,8);		if (c!=null) g.setColor(c);		super.paint(g);	}}