/* Code for stratigraphic tools package (http://mesquiteproject.org/... ).Copyright 2005 by Sébastien Josse, Thomas Moreau and Michel Laurin.Based on Mesquite source code copyright 1997-2005 W. & D. Maddison.Available for Mesquite version 1.06Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.stratigraphictools;import mesquite.lib.*;/* ======================================================================== *//** An object of this class represents a single set of taxa (a TAXA block in a NEXUS file).*/public class STTaxa extends Taxa {	protected int numTaxa;	protected Taxon[] taxon;	private MesquiteTree defaultTree;	private Clades clades;	String equalTaxaMessage = null;	boolean writeToEqualTaxaMessage = false;	public static final int MAXNUMTAXA = 32000;	public static int totalCreated = 0;	protected boolean inFlux = false;	private boolean duplicate = false;		public STTaxa(int numTaxa) {		super(numTaxa); //For associable		clades = new Clades();		this.numTaxa = numTaxa;		totalCreated++;		name = "Untitled Block of Period";		taxon = new Taxon[numTaxa];		for (int it = 0; it<numTaxa; it++) {			taxon[it]= new Taxon(this);			taxon[it].number = it;			taxon[it].setName("period " + Integer.toString(it + 1));		} 	}	 	/*.................................................................................................................*/ 	/** gets the explanation (footnote) of this block of taxa*/	public String getExplanation() {		String extra = "This block of period has " + getNumTaxa() + " period.\n";		return extra;	} 	/*.................................................................................................................*/	public void dispose(){		for (int it = 0; it<numTaxa; it++) {			taxon[it]= null;		} 		numTaxa = 0;		taxon = null;		clades = null;		super.dispose();	} 	/*.................................................................................................................*/	public String getTypeName(){		return "Taxa";	} 	/*.................................................................................................................*/	/** Call this before you might call the equals method if you wish the equals method to store a list of reasons for differences between taxa.  */	public void prepareEqualTaxaMessage() {		equalTaxaMessage = "";		writeToEqualTaxaMessage = true;	} 	/*.................................................................................................................*/	/** Call this before you might call the equals method if you wish the equals method to store a list of reasons for differences between taxa.  */	public void turnOffEqualTaxaMessage() {		equalTaxaMessage = "";		writeToEqualTaxaMessage = false;	} 	/*.................................................................................................................*/	public String getEqualTaxaMessage() {		return equalTaxaMessage;	}	/*.................................................................................................................*/	public void appendToEqualTaxaMessage(String s) {		if (writeToEqualTaxaMessage)			if (StringUtil.blank(equalTaxaMessage))				equalTaxaMessage += s;			else				equalTaxaMessage += "; " + s;	} 	/*.................................................................................................................*/	/** Returns true if passed Taxa is the exact same, or if all of its taxon names are the same (CURRENTLY NEED TO BE IN THE SAME ORDER!!!) */	public boolean equals(STTaxa taxa, boolean ignoreName){		if (isDoomed()) {			return false;		}		if (taxa == this) {			return true;		}		else if (taxa == null) {			appendToEqualTaxaMessage("period block null");			return false;		}		else if (taxa.getNumTaxa() !=numTaxa) {			appendToEqualTaxaMessage("Different numbers of period");			return false;		}		if (!ignoreName && name!=null && taxa.name!=null && !name.equalsIgnoreCase(taxa.name)) {			appendToEqualTaxaMessage("Period blocks have different names");			return false;		}		for (int it=0; it<numTaxa; it++)			if (taxa.getTaxon(taxon[it].getName())==null) {				appendToEqualTaxaMessage("Period "+taxon[it].getName() + " not found in second matrix");				return false;			}		for (int it=0; it<numTaxa; it++)			if (getTaxon(taxa.getTaxonName(it))==null) {				appendToEqualTaxaMessage("Period "+taxa.getTaxonName(it) + " not found in original matrix");				return false;			}		return true;	} 	/*.................................................................................................................*/ 	/** Note this does not yield a full clone of the taxa, as Associable and Illustration info is not cloned */	public Taxa cloneTaxa() {		if (isDoomed())			return null;		Taxa temp = new Taxa(numTaxa);		temp.setName(name);		//temp.name = name;		for (int it = 0; it<numTaxa; it++) {			temp.getTaxon(it).setName(taxon[it].getName());			//temp.taxon[it].setName(taxon[it].getName());		} 		return temp;	}	/*.................................................................................................................*/    	 public Object doCommand(String commandName, String arguments, CommandChecker checker) {    	 	 if (checker.compare(this.getClass(), "Sets the name of the period", "[number of period, 0 based]", commandName, "setTaxonName")) {			MesquiteInteger pos = new MesquiteInteger(0);			int c= MesquiteInteger.fromFirstToken(arguments, pos);			if (MesquiteInteger.isCombinable(c) && c >= 0 && c<numTaxa) {				String n = ParseUtil.getToken(arguments, pos);				setTaxonName(c, n);    	 		}    	 	}    	 	else { 			return  super.doCommand(commandName, arguments, checker); 		}		return null;   	 } 	/*.................................................................................................................*/	/** returns which taxon (i.e., its number) has the given name */  	public int whichTaxonNumber(String taxonName){   		return whichTaxonNumber(taxonName, false);  	}  	/*.................................................................................................................*/	/** returns which taxon (i.e., its number) has the given name */  	public int whichTaxonNumber(String taxonName, boolean caseSensitive){    		if (StringUtil.blank(taxonName))  			return -1;		if (caseSensitive){			for (int i=0; i<numTaxa; i++)				if (taxonName.equals(taxon[i].getName()))					return i;		}		else {			for (int i=0; i<numTaxa; i++)				if (taxonName.equalsIgnoreCase(taxon[i].getName()))					return i;		}		try {			int tNum = Taxon.toInternal(MesquiteInteger.fromString(taxonName, false));			if ((tNum<numTaxa) && (tNum>=0))				return tNum;		}		catch (NumberFormatException e) {			System.out.println("ERROR: bad period number/period name: " + taxonName);			return -1;		}		return -1;	} 	/*.................................................................................................................*/	/** returns which number has the given taxon.  */  	public int whichTaxonNumber(Taxon t){  		for (int i=0; i<numTaxa; i++)			if (t == taxon[i])				return i;		return -1;	} 	/*.................................................................................................................*/	public String getUniqueName(String base){		int count =1;		while (true){						String candidate;			if (count==1)				candidate = base;			else				candidate = base + count;			if (whichTaxonNumber(candidate)<0)				return candidate;			count++;		}	} 	/*.................................................................................................................*/	public void setName(String name) { 		setDirty(true);		this.name = name;		notifyListeners(this, new Notification(MesquiteListener.NAMES_CHANGED));		if (getHShow()) {			MesquiteTrunk.mesquiteTrunk.refreshBrowser(FileElement.class);		}	} 	/*.................................................................................................................*/	public String getName() {		if (name==null)			return "Untitled Block of Period";		return name;	} 	/*.................................................................................................................*/	/** Gets the default tree for these taxa (default default is bush) */	public MesquiteTree getDefaultTree() {		if (isDoomed())			return null;		if (defaultTree == null) {			MesquiteTree tree = new MesquiteTree(this);			tree.setToDefaultBush(getNumTaxa(), false);			return tree;		}		return defaultTree;	} 	/*.................................................................................................................*/	/** Gets the default tree for these taxa (default default is bush) */	public MesquiteTree getDefaultDichotomousTree(MesquiteTree tree) {		if (isDoomed())			return null;		if (tree == null || tree.getTaxa()!=this) {			tree = new MesquiteTree(this);		}		tree.setToDefaultLadder(getNumTaxa(), false);		return tree;	} 	/*.................................................................................................................*/	/** sets the default tree for these taxa */	public void setDefaultTree(MesquiteTree tree) {		defaultTree = tree;		notifyListeners(this, new Notification(MesquiteListener.UNKNOWN));	} 	/*.................................................................................................................*/	public int getNumTaxa(){		if (isDoomed())			return 0;		return numTaxa;	}	protected String findName(int num, Taxon[] t){		while (true) {			String s = "period " + Integer.toString(num);			if (getTaxon(s) == null && !nameInTaxonArray(s, t))				return s;			num++;		}	}	private boolean nameInTaxonArray(String name, Taxon[] t){		if (t == null || name == null)			return false;		for (int i=0; i<t.length; i++)			if (t[i] != null && name.equals(t[i].getName()))				return true;		return false;	} 	/*.................................................................................................................*/ 	/** Adds new taxa starting just after taxon "starting" */  	public boolean addParts(int starting, int num){  		if (isDoomed())			return false;		if (num<=0)			return false;		inFlux = true;		if (starting<0)			starting = -1;		else if (starting>=numTaxa)			starting = numTaxa-1;		int newNumTaxa = numTaxa + num;		Taxon[] newTaxonArray = new Taxon[newNumTaxa];		for (int it = 0; it<=starting; it++) 			newTaxonArray[it]=taxon[it];		for (int it = 0; it<num; it++) {			newTaxonArray[starting+it+1]= new Taxon(this);			newTaxonArray[starting+it+1].setName(findName(starting+it+2, newTaxonArray));			newTaxonArray[starting+it+1].number = it+num;		} 		for (int it = 0; it<numTaxa-starting-1; it++) 			newTaxonArray[it +starting+num+1]= taxon[starting + it+1];		taxon = newTaxonArray;		numTaxa= newNumTaxa;  		super.addParts(starting, num); 		inFlux = false;		return true;	}	/*.................................................................................................................*/ 	/** Deletes num taxa beginning at and including "starting" */	public boolean deleteParts(int starting, int num){  		if (num<=0 || starting<0 || starting>=numTaxa)			return false;		inFlux = true;		if (num+starting>numTaxa)			num = numTaxa-starting;		int newNumTaxa = numTaxa - num;		Taxon[] newTaxonArray = new Taxon[newNumTaxa];		for (int it = 0; it<starting; it++) 			newTaxonArray[it]=taxon[it];		for (int it = starting+num; it<numTaxa; it++)			newTaxonArray[it-num]=taxon[it];					taxon = newTaxonArray;		numTaxa= newNumTaxa;  		super.deleteParts(starting, num); 		inFlux = false;		return true;	}	/*.................................................................................................................*/ 	/** Swaps taxa first and second*/	public boolean swapTaxa(int first, int second, boolean notify){  		if (isDoomed())			return false;		if (first>=taxon.length || second >=taxon.length || first <0 || second <0 || first == second)			return false;		swapParts(first, second);		inFlux = true;		if (notify)			notifyListeners(this, new Notification(MesquiteListener.PARTS_MOVED));		inFlux = false;		return false;	}	/*...........................................................*/	public boolean swapParts(int first, int second) {		if (first<0 || first>=taxon.length || second<0 || second>=taxon.length) 			return false;		inFlux = true;		Taxon temp = taxon[first];		taxon[first] = taxon[second];		taxon[second] = temp;		boolean success =  super.swapParts(first, second);		inFlux = false;		return success;	}	/*.................................................................................................................*/ 	/** Moves num taxa starting at first to be just after justAfter*/	public boolean moveParts(int first, int num, int justAfter){  		if (isDoomed())			return false;		inFlux = true;		if (justAfter>=taxon.length)			justAfter = taxon.length-1;		if (justAfter<0)			justAfter = -1;		Taxon[] newTaxa = new Taxon[taxon.length];		if (first>justAfter){			int count =0;			for (int i=0; i<=justAfter; i++)				newTaxa[count++]=taxon[i];			for (int i=first; i<=first+num-1; i++)				newTaxa[count++]=taxon[i];			for (int i=justAfter+1; i<=first-1; i++)				newTaxa[count++]=taxon[i];			for (int i=first+num; i<taxon.length; i++)				newTaxa[count++]=taxon[i];		}		else {   // (first<=justAfter)			int count =0;			for (int i=0; i<=first-1; i++)				newTaxa[count++]=taxon[i];			for (int i=first+num; i<=justAfter; i++)				newTaxa[count++]=taxon[i];			for (int i=first; i<=first+num-1; i++)				newTaxa[count++]=taxon[i];			for (int i=justAfter+1; i<taxon.length; i++)				newTaxa[count++]=taxon[i];		}		taxon = newTaxa;  		super.moveParts(first, num, justAfter); 		inFlux = false;		return true;	}	public boolean isInFlux(){		return inFlux;	}	/*.................................................................................................................*/	public Taxon getTaxon(String name) {		return getTaxon(name, false);	}	/*.................................................................................................................*/	public Taxon getTaxon(String name, boolean caseSensitive) {		if (isDoomed())			return null;		if (name != null) {			int it = whichTaxonNumber(name, caseSensitive);			if (it>=0)			 	return taxon[it];		}		return null;	}	/*.................................................................................................................*/	public Taxon getTaxonByID(long id) {		if (isDoomed())			return null;		for (int i=0; i<numTaxa; i++)			if (taxon[i].getID() == id)				return taxon[i];		return null;	}	public long[] getTaxaIDs(){		long[] taxaIDs = new long[numTaxa];		for (int i=0; i<numTaxa; i++) {			Taxon t = getTaxon(i);			if (t!=null)				taxaIDs[i] = t.getID();		}		return taxaIDs;	}	/*.................................................................................................................*/	public Taxon getTaxon(int it) {		if (isDoomed())			return null;		if (it>=0 && it<numTaxa)			return taxon[it];		else return null;	}	/*.................................................................................................................*/	public void setTaxon(int it, Taxon t) { 		setDirty(true);		taxon[it] = t;		notifyListeners(this, new Notification(MesquiteListener.PARTS_CHANGED));	}	/*.................................................................................................................*/	public String getTaxonName(int it) {		if (it>=0 && it<numTaxa)		return taxon[it].getName();		else return "";	}	/*.................................................................................................................*/	public void setTaxonName(int it, String s) {		setTaxonName(it, s, true);	}	/*.................................................................................................................*/	public void setTaxonName(int it, String s, boolean notify) {		if (it>=0 && it<numTaxa) {			setDirty(true);		 	taxon[it].setName(s);			warnIfNameIllegal(it, s);			if (notify)				notifyListeners(this,  new Notification(MesquiteListener.NAMES_CHANGED, new int[] {it}));		}	}	/*.................................................................................................................*/	private void warnIfNameIllegal(int it, String s){		String st = checkNameLegality(it, s);		if (st !=null)			MesquiteMessage.warnProgrammer(st);	}	/*.................................................................................................................*/	public String checkNameLegality(int it, String s){			if(s.indexOf(';') != -1) return "The period name can't contain the character ';'"; 		return null;	}	/*.................................................................................................................*/	public String getName(int it) {		if (it>=0 && it<numTaxa)		return taxon[it].getName();		else return "";	}	/*.................................................................................................................*/	public int getLongestTaxonNameLength() {		int maxLength = 0;		int itLength;		for (int it = 0; it<numTaxa; it++) {			itLength = getName(it).length();			if (itLength>maxLength)				maxLength = itLength;		}		return maxLength;	}	/*.................................................................................................................*/	public Taxon userChooseTaxon(MesquiteWindow parent, String message) {		Listable[] names = new Listable[numTaxa];		for (int i=0; i<numTaxa; i++)			names[i] = taxon[i];		Listable chosen = ListDialog.queryList(parent, "Choose period", message, MesquiteString.helpString, names, -1);		return (Taxon) chosen;	}	/*.................................................................................................................*/	public String toString(){		return "Period block (name: " + getName() + " number of period: " + numTaxa + " id: " + getID() + ")";	}		public Clades getClades(){		if (isDoomed())			return null;		return clades;	}	/** returns whether this taxa is marked as a duplicate of another.  This is used for 	merging taxa and subsequently saving the file. The system is kludgey and may change */	public boolean isDuplicate(){		return duplicate;	}	/** sets whether this taxa is marked as a duplicate of another.  This is used for 	merging taxa and subsequently saving the file. The system is kludgey and may change */	public void setDuplicate(boolean dup){		this.duplicate = dup;	}	/* ---------------- for HNode interface ----------------------*/	public boolean getHShow(){		return true; 	}	}